version: 2.1

description: |
  Shared commands and jobs for Freegle testing and app builds across repositories.
  Used by FreegleDocker and submodule repos (iznik-server, iznik-server-go, iznik-nuxt3).

executors:
  machine-executor:
    machine:
      image: ubuntu-2404:current
      docker_layer_caching: true
    resource_class: large
    environment:
      DOCKER_BUILDKIT: 1
      COMPOSE_DOCKER_CLI_BUILD: 1

  android-executor:
    docker:
      - image: cimg/android:2025.10-node
    resource_class: large

  macos-executor:
    macos:
      xcode: 26.2.0
    resource_class: m4pro.medium

commands:
  # === Setup Commands ===

  setup-dependencies:
    description: "Install system dependencies and docker-compose"
    steps:
      - run:
          name: Kill stale apt processes
          command: |
            # Kill any stale unattended-upgrade processes that may block apt
            sudo pkill -9 unattended-upgrade 2>/dev/null || true
            sudo pkill -9 apt 2>/dev/null || true
            sudo pkill -9 dpkg 2>/dev/null || true
            # Remove stale apt locks
            sudo rm -f /var/lib/apt/lists/lock 2>/dev/null || true
            sudo rm -f /var/lib/dpkg/lock* 2>/dev/null || true
            sudo rm -f /var/cache/apt/archives/lock 2>/dev/null || true
            # Reconfigure dpkg if interrupted
            sudo dpkg --configure -a 2>/dev/null || true
            echo "Cleaned up stale apt processes and locks"
      - run:
          name: Install system dependencies
          command: |
            # Try to create swap file - may fail on self-hosted runners (that's OK)
            echo "Attempting swap file creation..."
            if sudo fallocate -l 8G /swapfile 2>/dev/null && \
               sudo chmod 600 /swapfile && \
               sudo mkswap /swapfile 2>/dev/null && \
               sudo swapon /swapfile 2>/dev/null; then
              echo "Swap enabled:"
              free -h
            else
              echo "Swap creation skipped (self-hosted runner or insufficient permissions)"
              echo "Current memory:"
              free -h
            fi

            sudo apt-get update
            sudo apt-get install -y curl jq file

            # Install latest stable docker-compose with retry and validation
            COMPOSE_VERSION=$(curl -sf --retry 3 --retry-delay 5 https://api.github.com/repos/docker/compose/releases/latest | jq -r '.tag_name')
            if [ -z "$COMPOSE_VERSION" ] || [ "$COMPOSE_VERSION" = "null" ]; then
              echo "Failed to get docker-compose version from API, using fallback"
              COMPOSE_VERSION="v2.32.4"
            fi
            echo "Installing docker-compose ${COMPOSE_VERSION}"

            # Download with -f to fail on HTTP errors, retry on transient failures
            for attempt in 1 2 3; do
              echo "Download attempt $attempt..."
              if sudo curl -fL --retry 3 --retry-delay 10 \
                "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" \
                -o /usr/local/bin/docker-compose; then

                # Validate it's a binary, not an HTML error page
                if file /usr/local/bin/docker-compose | grep -q "ELF"; then
                  echo "docker-compose downloaded and validated successfully"
                  break
                else
                  echo "Downloaded file is not a valid binary:"
                  file /usr/local/bin/docker-compose
                  head -5 /usr/local/bin/docker-compose
                  sudo rm -f /usr/local/bin/docker-compose
                fi
              fi

              if [ $attempt -lt 3 ]; then
                echo "Download failed, waiting 30s before retry..."
                sleep 30
              fi
            done

            if [ ! -f /usr/local/bin/docker-compose ] || ! file /usr/local/bin/docker-compose | grep -q "ELF"; then
              echo "ERROR: Failed to download valid docker-compose binary after 3 attempts"
              exit 1
            fi

            sudo chmod +x /usr/local/bin/docker-compose
            docker-compose --version
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Start resource monitor
          background: true
          command: |
            echo "Resource monitor started - logging every 30 seconds"
            while true; do
              echo ""
              echo "========================================"
              echo "RESOURCE CHECK: $(date '+%Y-%m-%d %H:%M:%S')"
              echo "========================================"
              echo "--- Memory ---"
              free -h
              echo "--- Swap Usage ---"
              swapon --show
              echo "--- CPU Load ---"
              uptime
              echo "--- Disk I/O (iowait% shows disk bottleneck) ---"
              iostat -x 1 2 | tail -n +3
              echo "--- Top 5 Memory Consumers ---"
              ps aux --sort=-%mem | head -6
              echo "--- Docker Stats ---"
              docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" 2>/dev/null || echo "No containers running"
              sleep 30
            done

  start-docker-services:
    description: "Start Docker Compose services with proper setup"
    parameters:
      reason:
        type: string
        default: "Starting Docker services"
    steps:
      - run:
          name: Start Docker services
          max_auto_reruns: 3
          auto_rerun_delay: 10s
          command: |
            echo "<< parameters.reason >>"

            # Clean up any existing containers first
            docker-compose -f docker-compose.yml down --remove-orphans || true
            docker system prune -f || true

            # Fix memory overcommit for Redis
            sudo sysctl vm.overcommit_memory=1
            echo "Set vm.overcommit_memory=1 for Redis"

            # Create secrets files after cleanup, right before Docker startup
            echo "Creating secrets files after cleanup:"
            mkdir -p secrets
            echo "placeholder" > secrets/lovejunk-api.txt
            echo "placeholder" > secrets/lovejunk-secret.txt
            echo "placeholder" > secrets/partner-key.txt
            echo "placeholder" > secrets/partner-name.txt
            echo "placeholder" > secrets/image-domain.txt
            echo "Current working directory: $(pwd)"
            ls -la secrets/

      - run:
          name: Build containers
          command: |
            # Pre-pull base image once (avoids multiple registry checks during parallel builds)
            echo "Pre-pulling base image..."
            docker pull ghcr.io/freegle/freegle-base:latest

            # Build only containers needed for CI tests (skip dev containers)
            # This saves ~2-3 minutes by not building freegle-dev-local, modtools-dev-local, ai-support-helper
            echo "Building CI-required containers..."

            # Retry logic for transient network errors (ECONNRESET, etc.) during npm install
            MAX_RETRIES=3
            RETRY_DELAY=30

            for attempt in $(seq 1 $MAX_RETRIES); do
              echo "Build attempt $attempt of $MAX_RETRIES..."

              if docker-compose -f docker-compose.yml build --no-cache \
                apiv1 apiv1-phpunit apiv2 \
                freegle-prod-local modtools-prod-local \
                playwright status batch; then
                echo "‚úÖ Build succeeded on attempt $attempt"
                break
              else
                if [ $attempt -lt $MAX_RETRIES ]; then
                  echo "‚ö†Ô∏è Build failed on attempt $attempt, retrying in ${RETRY_DELAY}s..."
                  # Clean up any partial builds
                  docker-compose -f docker-compose.yml down --remove-orphans 2>/dev/null || true
                  docker system prune -f 2>/dev/null || true
                  sleep $RETRY_DELAY
                else
                  echo "‚ùå Build failed after $MAX_RETRIES attempts"
                  exit 1
                fi
              fi
            done

            # Start all services
            docker-compose -f docker-compose.yml up -d

            echo "Waiting for basic services to start..."
            sleep 30

            echo "Service status:"
            docker-compose -f docker-compose.yml ps

            # Verify expected container names exist (fail fast if container_name isn't working)
            echo ""
            echo "=== Verifying container names ==="
            # Containers needed for CI tests (dev containers excluded as they're not used in tests)
            ALL_CONTAINERS="freegle-traefik freegle-percona freegle-postgres freegle-phpmyadmin freegle-mailpit freegle-beanstalkd freegle-spamassassin freegle-redis freegle-delivery freegle-tusd freegle-status freegle-host-scripts freegle-apiv1 freegle-apiv1-phpunit freegle-apiv2 freegle-batch freegle-prod-local modtools-prod-local freegle-playwright"
            MISSING=""
            for container in $ALL_CONTAINERS; do
              if docker inspect "$container" >/dev/null 2>&1; then
                echo "‚úÖ $container"
              else
                echo "‚ùå $container NOT FOUND"
                MISSING="$MISSING $container"
              fi
            done

            if [ -n "$MISSING" ]; then
              echo ""
              echo "ERROR: Containers missing:$MISSING"
              echo "This usually means container_name directives in docker-compose.yml are not working."
              echo ""
              echo "Actual running containers:"
              docker ps --format "table {{.Names}}\t{{.Status}}"
              exit 1
            fi
            echo ""
            echo "‚úÖ All containers verified"

  clone-freegle-docker:
    description: "Clone FreegleDocker and initialize submodules"
    steps:
      - run:
          name: Clone FreegleDocker
          command: |
            git clone https://github.com/Freegle/FreegleDocker.git ~/FreegleDocker
            cd "$HOME/FreegleDocker"
            git submodule update --init --recursive --jobs 4

            # ModTools is now built from iznik-nuxt3/modtools (same repo, different build)
            echo "=== Verifying modtools directory ==="
            ls -la iznik-nuxt3/modtools/Dockerfile* || echo "WARNING: modtools/Dockerfile files not found"
          max_auto_reruns: 3
          auto_rerun_delay: 10s

  replace-submodule:
    description: "Replace a submodule with PR code"
    parameters:
      submodule:
        type: string
        description: "Name of submodule directory (iznik-server, iznik-server-go, iznik-nuxt3)"
      source:
        type: string
        default: "~/project"
        description: "Path to PR code"
    steps:
      - run:
          name: Replace << parameters.submodule >> with PR code
          command: |
            cd "$HOME/FreegleDocker"
            rm -rf << parameters.submodule >>
            cp -r << parameters.source >> << parameters.submodule >>

  build-submodule-container:
    description: "Build the container for a replaced submodule"
    parameters:
      container:
        type: string
        description: "Container name to build (apiv2, apiv1, freegle-prod-local, etc.)"
    steps:
      - run:
          name: Build << parameters.container >> container
          command: |
            cd "$HOME/FreegleDocker"
            echo "üî® Building << parameters.container >> container with updated code..."
            docker-compose -f docker-compose.yml build << parameters.container >>
            echo "‚úÖ << parameters.container >> container built successfully"

  start-services:
    description: "Create secrets and start Docker services"
    steps:
      - run:
          name: Create secrets files
          command: |
            cd "$HOME/FreegleDocker"
            mkdir -p secrets
            echo "placeholder" > secrets/lovejunk-api.txt
            echo "placeholder" > secrets/lovejunk-secret.txt
            echo "placeholder" > secrets/partner-key.txt
            echo "placeholder" > secrets/partner-name.txt
            echo "placeholder" > secrets/image-domain.txt
      - run:
          name: Fix memory overcommit for Redis
          command: sudo sysctl vm.overcommit_memory=1 || true
      - run:
          name: Start Docker services
          command: |
            cd "$HOME/FreegleDocker"
            if ! docker-compose -f docker-compose.yml up -d; then
              echo "‚ùå Docker Compose failed to start services"
              echo ""
              echo "=== Container Status ==="
              docker-compose -f docker-compose.yml ps -a
              echo ""
              echo "=== freegle-apiv1 logs ==="
              docker logs freegle-apiv1 2>&1 || echo "No logs available"
              echo ""
              echo "=== freegle-apiv2 logs ==="
              docker logs freegle-apiv2 2>&1 || echo "No logs available"
              echo ""
              echo "=== All container logs ==="
              docker-compose -f docker-compose.yml logs --tail 50 2>&1 || true
              exit 1
            fi
            echo "Waiting for basic services to start..."
            sleep 30
            echo "Service status:"
            docker-compose -f docker-compose.yml ps

  wait-for-basic-services:
    description: "Wait for API v1 and v2 services to be healthy"
    steps:
      - run:
          name: Wait for API services to be ready
          command: |
            # Support both FreegleDocker main build (~/project) and submodule tests (~/FreegleDocker)
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "Waiting for API v1 and v2 services to be healthy..."

            start_time=$(date +%s)
            timeout_duration=600  # 10 minutes for basic services

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Timeout waiting for API services after 10 minutes"
                echo ""
                echo "=== Final status API response ==="
                curl -s http://localhost:8081/api/status/all 2>/dev/null | jq . || echo "(status service not responding)"
                echo ""
                echo "=== Docker container health ==="
                docker ps --format 'table {{.Names}}\t{{.Status}}' 2>/dev/null || true
                echo ""
                echo "=== Status container logs (last 30) ==="
                docker logs freegle-status --tail 30 2>&1 || true
                echo ""
                echo "=== API v1 container logs (last 30) ==="
                docker logs freegle-apiv1-phpunit --tail 30 2>&1 || true
                echo ""
                echo "=== API v2 container logs (last 30) ==="
                docker logs freegle-apiv2 --tail 30 2>&1 || true
                echo ""
                echo "=== Batch container logs (last 30) ==="
                docker logs freegle-batch --tail 30 2>&1 || true
                exit 1
              fi

              # Check if status service is responding
              if curl -f -s http://localhost:8081 > /dev/null 2>&1; then
                echo "‚úÖ Status service is responding!"

                # Get health status from status service
                health_response=$(curl -s http://localhost:8081/api/status/all 2>/dev/null || echo '{}')

                # Check if API v1 and v2 are healthy
                apiv1_status=$(echo "$health_response" | jq -r '.apiv1.status // "unknown"')
                apiv2_status=$(echo "$health_response" | jq -r '.apiv2.status // "unknown"')

                if [ "$apiv1_status" = "success" ] && [ "$apiv2_status" = "success" ]; then
                  echo "‚úÖ API v1 and v2 services are healthy!"
                  break
                else
                  elapsed_min=$((elapsed / 60))
                  echo "[${elapsed_min}m] API v1: $apiv1_status, API v2: $apiv2_status - waiting..."
                fi
              else
                echo "Status service not yet responding..."
              fi

              sleep 10
            done

            echo "üéâ API services are ready!"
          no_output_timeout: 15m

  wait-for-prod-container:
    description: "Wait for production containers to be healthy"
    steps:
      - run:
          name: Wait for production containers to be healthy
          command: |
            # Support both FreegleDocker main build (~/project) and submodule tests (~/FreegleDocker)
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "‚è≥ Waiting for production containers to be healthy..."
            start_time=$(date +%s)
            timeout_duration=1200  # 20 minutes

            # Track if containers are actually responding (not just Docker status)
            freegle_http_ready=false
            modtools_http_ready=false

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Timeout waiting for production containers after 20 minutes"
                echo "Freegle HTTP ready: $freegle_http_ready"
                echo "ModTools HTTP ready: $modtools_http_ready"
                echo ""
                echo "=== Freegle container logs ==="
                docker logs freegle-prod-local --tail 50 2>&1 || true
                echo ""
                echo "=== ModTools container logs ==="
                docker logs modtools-prod-local --tail 50 2>&1 || true
                exit 1
              fi

              # Check Docker status first (to see if containers are running)
              health_response=$(curl -s http://localhost:8081/api/status/all 2>/dev/null || echo '{}')
              freegle_prod_status=$(echo "$health_response" | jq -r '.["freegle-prod-local"].status // "unknown"')
              modtools_prod_status=$(echo "$health_response" | jq -r '.["modtools-prod-local"].status // "unknown"')

              # Also make actual HTTP requests to verify servers are responding
              # This is needed because Docker status is "running" during npm build
              if [ "$freegle_http_ready" = "false" ]; then
                if curl -s -f -o /dev/null --max-time 5 http://localhost:3012/ 2>/dev/null; then
                  freegle_http_ready=true
                  echo "‚úÖ Freegle production container is responding on HTTP"
                fi
              fi

              if [ "$modtools_http_ready" = "false" ]; then
                if curl -s -f -o /dev/null --max-time 5 http://localhost:3013/ 2>/dev/null; then
                  modtools_http_ready=true
                  echo "‚úÖ ModTools production container is responding on HTTP"
                fi
              fi

              # Both must be running AND responding to HTTP
              if [ "$freegle_http_ready" = "true" ] && [ "$modtools_http_ready" = "true" ]; then
                echo "‚úÖ Both production containers are healthy and responding!"
                break
              else
                elapsed_min=$((elapsed / 60))
                echo "[${elapsed_min}m] Docker: FD=$freegle_prod_status MT=$modtools_prod_status | HTTP: FD=$freegle_http_ready MT=$modtools_http_ready - waiting..."

                # Show container logs periodically to track build progress
                if [ $((elapsed % 60)) -lt 15 ]; then
                  echo "--- FD Production container recent output ---"
                  docker logs freegle-prod-local --tail 3 2>&1 || true
                fi

                sleep 15
              fi
            done
          no_output_timeout: 25m

  # === Test Execution Commands ===

  run-go-tests:
    description: "Run Go tests via the status service API and upload coverage"
    parameters:
      reason:
        type: string
        default: "Running Go tests"
    steps:
      - run:
          name: Run Go tests and upload coverage
          command: |
            # Support both FreegleDocker (~/project) and submodule (~/FreegleDocker) paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "üß™ << parameters.reason >>..."

            # Trigger tests via API with coverage enabled
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" "http://localhost:8081/api/tests/go?coverage=true")
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger Go tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ Go tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring Go test progress..."
            start_time=$(date +%s)
            timeout_duration=2100  # 35 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Go tests timed out after 35 minutes"
                exit 1
              fi

              sleep 5
              status_response=$(curl -s http://localhost:8081/api/tests/go/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')
              passed=$(echo "$status_response" | jq -r '.progress.passed // 0')
              failed=$(echo "$status_response" | jq -r '.progress.failed // 0')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status | ${passed}‚úì ${failed}‚úó | $message"

              if [ "$status" = "completed" ]; then
                echo "üéâ Go tests completed!"
                echo "‚úÖ Go tests passed!"
                echo "GO_TESTS_PASSED=true" >> $BASH_ENV
                break
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå Go tests failed!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -50
                echo "GO_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

            # Upload Go coverage immediately after tests complete
            echo "üì§ Uploading Go coverage..."
            if [ -z "${COVERALLS_REPO_TOKEN}" ]; then
              echo "‚ö†Ô∏è COVERALLS_REPO_TOKEN not set - skipping coverage upload"
              exit 0
            fi

            # Copy coverage file from container
            if docker cp freegle-apiv2:/app/coverage.out iznik-server-go/coverage.out 2>/dev/null; then
              echo "‚úÖ Found Go coverage file"

              # Install gcov2lcov
              go install github.com/jandelgado/gcov2lcov@latest || echo "gcov2lcov install warning"

              if command -v gcov2lcov > /dev/null; then
                cd iznik-server-go
                if gcov2lcov -infile=coverage.out -outfile=coverage.lcov 2>&1 && [ -s coverage.lcov ]; then
                  # Copy lcov to original checkout for coveralls (needs .git)
                  if [ -d ~/project/.git ]; then
                    cp coverage.lcov ~/project/
                    cd ~/project
                  else
                    cd ..
                  fi

                  # Install coveralls and upload
                  npm install -g coveralls
                  export COVERALLS_SERVICE_NAME="circleci"
                  export COVERALLS_SERVICE_JOB_ID="${CIRCLE_BUILD_NUM}"
                  if cat coverage.lcov | coveralls; then
                    echo "‚úÖ Go coverage uploaded successfully"
                  else
                    echo "‚ùå Go coverage upload failed"
                    exit 1
                  fi
                else
                  echo "‚ùå Failed to convert Go coverage to lcov format"
                  exit 1
                fi
              else
                echo "‚ùå gcov2lcov not found"
                exit 1
              fi
            else
              echo "‚ùå Go coverage file not found"
              exit 1
            fi
          no_output_timeout: 40m

  run-php-tests:
    description: "Run PHPUnit tests via the status service API"
    parameters:
      reason:
        type: string
        default: "Running PHPUnit tests"
    steps:
      - restore_cache:
          keys:
            - geoip-db-v1
      - run:
          name: Run PHPUnit tests
          command: |
            # Support both FreegleDocker (~/project) and submodule (~/FreegleDocker) paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "üêò << parameters.reason >>..."

            # Restore GeoIP database from cache if available
            # Copy to the dedicated PHPUnit test container since that's where tests run
            if [ -f ~/geoip-cache/GeoLite2-Country.mmdb ]; then
              echo "üìç Restoring GeoIP database from cache..."
              docker exec freegle-apiv1-phpunit mkdir -p /var/lib/GeoIP
              docker cp ~/geoip-cache/GeoLite2-Country.mmdb freegle-apiv1-phpunit:/var/lib/GeoIP/GeoLite2-Country.mmdb
              docker cp ~/geoip-cache/GeoLite2-City.mmdb freegle-apiv1-phpunit:/var/lib/GeoIP/GeoLite2-City.mmdb 2>/dev/null || true
              echo "‚úÖ GeoIP database restored from cache"
            else
              echo "‚ö†Ô∏è No GeoIP cache found - container will attempt download"
              # Give container time to download GeoIP (it has retry logic)
              echo "Waiting for GeoIP download attempt..."
              sleep 30
            fi

            # Database schema and test environment already set up by setup-test-database step
            # Just verify the database is accessible
            echo "Verifying database connection..."
            docker exec freegle-apiv1 sh -c "mysql -h percona -u root -piznik -e 'SELECT 1 FROM iznik.groups LIMIT 1'" || {
              echo "Database not ready, setting up..."
              docker exec freegle-apiv1 sh -c "cd /var/www/iznik && \
                sed -i 's/ROW_FORMAT=DYNAMIC//g' install/schema.sql && \
                sed -i 's/timestamp(3)/timestamp/g' install/schema.sql && \
                sed -i 's/timestamp(6)/timestamp/g' install/schema.sql && \
                sed -i 's/CURRENT_TIMESTAMP(3)/CURRENT_TIMESTAMP/g' install/schema.sql && \
                sed -i 's/CURRENT_TIMESTAMP(6)/CURRENT_TIMESTAMP/g' install/schema.sql && \
                mysql -h percona -u root -piznik -e 'CREATE DATABASE IF NOT EXISTS iznik;' && \
                mysql -h percona -u root -piznik iznik < install/schema.sql && \
                mysql -h percona -u root -piznik iznik < install/functions.sql && \
                mysql -h percona -u root -piznik iznik < install/damlevlim.sql && \
                mysql -h percona -u root -piznik -e \"SET GLOBAL sql_mode = 'NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'\" && \
                mysql -h percona -u root -piznik -e \"SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\""
              docker exec freegle-apiv1 sh -c "cd /var/www/iznik && php install/testenv.php"
            }

            # Trigger tests via API
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/php)
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger PHP tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ PHP tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring PHP test progress..."
            start_time=$(date +%s)
            timeout_duration=2700  # 45 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå PHP tests timed out after 45 minutes"
                exit 1
              fi

              sleep 10
              status_response=$(curl -s http://localhost:8081/api/tests/php/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status"
              echo "Message: $message"

              if [ "$status" = "completed" ]; then
                echo "üéâ PHP tests completed!"
                echo "‚úÖ PHPUnit tests passed!"
                echo "PHP_TESTS_PASSED=true" >> $BASH_ENV
                break
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå PHP tests failed!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30

                # Show the failure details from the PHPUnit debug log
                echo ""
                echo "Extracting failure details from PHPUnit output..."
                # Use the dedicated PHPUnit test container (freegle-apiv1-phpunit)
                docker exec freegle-apiv1-phpunit sh -c '
                  if [ -f /tmp/phpunit-debug.log ]; then
                    echo "=== TEST FAILURES ==="
                    grep "##teamcity\[testFailed" /tmp/phpunit-debug.log | head -10 | while read -r line; do
                      test_name=$(echo "$line" | sed "s/.*name='"'"'\([^'"'"']*\)'"'"'.*/\1/")
                      message=$(echo "$line" | sed "s/.*message='"'"'\([^'"'"']*\)'"'"'.*/\1/")
                      details=$(echo "$line" | sed "s/.*details='"'"'\([^'"'"']*\)'"'"'.*/\1/" | sed "s/|n/\n/g")
                      if [ -n "$test_name" ]; then
                        echo "‚ùå $test_name"
                        [ -n "$message" ] && echo "   Message: $message"
                        [ -n "$details" ] && echo "   Details: $details"
                      fi
                    done

                    echo ""
                    echo "=== TEST SUMMARY ==="
                    tail -20 /tmp/phpunit-debug.log | grep -E "Tests:|FAILURES!|Skipped:" || echo "No summary found"
                  else
                    echo "Debug log not found"
                  fi
                ' || echo "Could not extract failure details"

                echo "PHP_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

            # Upload PHP coverage immediately after tests complete
            echo "üì§ Uploading PHP coverage..."
            if [ -z "${COVERALLS_REPO_TOKEN}" ]; then
              echo "‚ö†Ô∏è COVERALLS_REPO_TOKEN not set - skipping coverage upload"
              exit 0
            fi

            # Copy coverage file from container
            COVERAGE_FOUND=false
            if docker cp freegle-apiv1-phpunit:/var/www/iznik/test/ut/php/clover.xml /tmp/phpunit-clover.xml 2>/dev/null; then
              COVERAGE_FOUND=true
              echo "‚úÖ Found PHP coverage at /var/www/iznik/test/ut/php/clover.xml"
            elif docker cp freegle-apiv1-phpunit:/tmp/phpunit-coverage.xml /tmp/phpunit-clover.xml 2>/dev/null; then
              COVERAGE_FOUND=true
              echo "‚úÖ Found PHP coverage at /tmp/phpunit-coverage.xml"
            fi

            if [ "$COVERAGE_FOUND" = "true" ]; then
              # Install php-coveralls
              npm install -g coveralls
              docker exec freegle-apiv1 bash -c "cd /var/www/iznik && php composer.phar require php-coveralls/php-coveralls --dev" || echo "php-coveralls install warning"

              # Copy coverage file to container and upload
              docker cp /tmp/phpunit-clover.xml freegle-apiv1:/var/www/iznik/clover.xml
              docker exec freegle-apiv1 bash -c "cd /var/www/iznik && COVERALLS_REPO_TOKEN=${COVERALLS_REPO_TOKEN} COVERALLS_SERVICE_NAME=circleci COVERALLS_SERVICE_JOB_ID=${CIRCLE_BUILD_NUM} vendor/bin/php-coveralls -v --coverage_clover=clover.xml --json_path=/tmp/coveralls.json"

              if [ $? -eq 0 ]; then
                echo "‚úÖ PHP coverage uploaded successfully"
              else
                echo "‚ùå PHP coverage upload failed"
                exit 1
              fi
            else
              echo "‚ùå PHP coverage file not found"
              exit 1
            fi
          no_output_timeout: 50m
      - run:
          name: Save GeoIP database for caching
          when: always
          command: |
            # Copy GeoIP database from container for caching (if it exists)
            mkdir -p ~/geoip-cache
            docker cp freegle-apiv1:/var/lib/GeoIP/GeoLite2-Country.mmdb ~/geoip-cache/GeoLite2-Country.mmdb 2>/dev/null && \
              echo "‚úÖ GeoIP Country database saved for caching" || \
              echo "‚ö†Ô∏è GeoIP Country database not available to cache"
            docker cp freegle-apiv1:/var/lib/GeoIP/GeoLite2-City.mmdb ~/geoip-cache/GeoLite2-City.mmdb 2>/dev/null && \
              echo "‚úÖ GeoIP City database saved for caching" || \
              echo "‚ö†Ô∏è GeoIP City database not available to cache"
      - save_cache:
          key: geoip-db-v1
          paths:
            - ~/geoip-cache

  wait-for-batch-container:
    description: "Wait for batch container to be healthy and migrations to complete"
    steps:
      - run:
          name: Wait for batch container to be healthy
          command: |
            echo "‚è≥ Waiting for batch container to be healthy..."
            TIMEOUT=300
            ELAPSED=0
            while [ $ELAPSED -lt $TIMEOUT ]; do
              STATUS=$(docker inspect --format='{{.State.Health.Status}}' freegle-batch 2>/dev/null || echo "not_found")
              RUNNING=$(docker inspect --format='{{.State.Running}}' freegle-batch 2>/dev/null || echo "false")

              if [ "$STATUS" = "healthy" ]; then
                echo "‚úÖ Batch container is healthy!"
                break
              elif [ "$RUNNING" = "false" ]; then
                echo "‚ùå Batch container is not running!"
                echo "Container logs:"
                docker logs freegle-batch --tail 50 2>&1 || true
                exit 1
              fi

              echo "[$ELAPSED s] Batch container status: $STATUS (running: $RUNNING) - waiting..."
              sleep 5
              ELAPSED=$((ELAPSED + 5))
            done

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "‚ùå Timeout waiting for batch container to be healthy"
              echo "Container logs:"
              docker logs freegle-batch --tail 50 2>&1 || true
              exit 1
            fi

            # Verify migrations have completed by checking for ready marker file
            # The entrypoint creates /tmp/laravel-ready AFTER migrations complete
            echo "‚è≥ Verifying Laravel migrations are complete..."
            MIGRATION_TIMEOUT=120
            MIGRATION_ELAPSED=0
            while [ $MIGRATION_ELAPSED -lt $MIGRATION_TIMEOUT ]; do
              if docker exec freegle-batch test -f /tmp/laravel-ready 2>/dev/null; then
                echo "‚úÖ Laravel ready marker found - migrations complete"
                exit 0
              fi

              echo "[$MIGRATION_ELAPSED s] Waiting for /tmp/laravel-ready marker..."
              sleep 5
              MIGRATION_ELAPSED=$((MIGRATION_ELAPSED + 5))
            done

            echo "‚ùå Timeout waiting for migrations to complete"
            docker logs freegle-batch --tail 30 2>&1 || true
            exit 1

  setup-test-database:
    description: "Set up test database schema and test environment"
    steps:
      - run:
          name: Set up test database and environment
          command: |
            # Support both FreegleDocker (~/project) and submodule (~/FreegleDocker) paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "üóÑÔ∏è Setting up test database and environment..."

            # Verify required containers are still running
            echo "Verifying required containers..."
            for container in freegle-apiv1 freegle-percona; do
              if ! docker inspect -f '{{.State.Running}}' "$container" 2>/dev/null | grep -q "true"; then
                echo "‚ùå Container $container is not running!"
                echo ""
                echo "=== Container status ==="
                docker ps -a --filter "name=$container" --format "table {{.Names}}\t{{.Status}}\t{{.State}}"
                echo ""
                echo "=== Container logs (last 50 lines) ==="
                docker logs "$container" --tail 50 2>&1 || echo "Could not get logs"
                echo ""
                echo "=== All container statuses ==="
                docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.State}}" | head -30
                exit 1
              fi
              echo "‚úÖ $container is running"
            done

            # Load database schema first (use container name directly for reliability)
            echo "Loading database schema..."
            docker exec freegle-apiv1 sh -c "cd /var/www/iznik && \
              sed -i 's/ROW_FORMAT=DYNAMIC//g' install/schema.sql && \
              sed -i 's/timestamp(3)/timestamp/g' install/schema.sql && \
              sed -i 's/timestamp(6)/timestamp/g' install/schema.sql && \
              sed -i 's/CURRENT_TIMESTAMP(3)/CURRENT_TIMESTAMP/g' install/schema.sql && \
              sed -i 's/CURRENT_TIMESTAMP(6)/CURRENT_TIMESTAMP/g' install/schema.sql && \
              mysql -h percona -u root -piznik -e 'CREATE DATABASE IF NOT EXISTS iznik;' && \
              mysql -h percona -u root -piznik iznik < install/schema.sql && \
              mysql -h percona -u root -piznik iznik < install/functions.sql && \
              mysql -h percona -u root -piznik iznik < install/damlevlim.sql && \
              mysql -h percona -u root -piznik -e \"SET GLOBAL sql_mode = 'NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'\" && \
              mysql -h percona -u root -piznik -e \"SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\""

            # Set up test environment using testenv.php from iznik-server
            echo "Setting up test environment (FreeglePlayground group, test users, etc.)..."
            docker exec freegle-apiv1 sh -c "cd /var/www/iznik && php install/testenv.php"

            echo "‚úÖ Test database and environment ready!"

  run-vitest-tests:
    description: "Run Vitest unit tests for iznik-nuxt3 components"
    parameters:
      reason:
        type: string
        default: "Running Vitest unit tests"
    steps:
      - run:
          name: Install Node.js 22 for Vitest
          command: |
            echo "üì¶ Installing Node.js 22..."
            curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
            sudo apt-get install -y nodejs
            echo "‚úÖ Node.js $(node --version) installed"
      - run:
          name: Run Vitest unit tests
          command: |
            echo "üß™ << parameters.reason >>..."

            # Determine the iznik-nuxt3 directory
            if [ -d "$HOME/FreegleDocker/iznik-nuxt3" ]; then
              NUXT_DIR="$HOME/FreegleDocker/iznik-nuxt3"
            elif [ -d "$HOME/project/iznik-nuxt3" ]; then
              NUXT_DIR="$HOME/project/iznik-nuxt3"
            else
              echo "‚ùå Could not find iznik-nuxt3 directory"
              exit 1
            fi

            echo "üìÇ Using iznik-nuxt3 at: $NUXT_DIR"
            cd "$NUXT_DIR"

            # Check if vitest is configured
            if ! grep -q '"test:unit:run"' package.json; then
              echo "‚ö†Ô∏è Vitest not configured in package.json, skipping unit tests"
              exit 0
            fi

            # Install dependencies (using npm ci for faster, deterministic installs)
            echo "üì¶ Installing npm dependencies..."
            npm ci --prefer-offline --no-audit

            # Generate .nuxt directory (required for tsconfig.json extends)
            echo "üîß Running nuxi prepare..."
            npx nuxi prepare

            # Run vitest
            echo "üß™ Running Vitest unit tests..."
            npm run test:unit:run -- --reporter=verbose 2>&1 | tee /tmp/vitest-output.log
            VITEST_EXIT_CODE=${PIPESTATUS[0]}

            if [ $VITEST_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Vitest unit tests passed!"
            else
              echo "‚ùå Vitest unit tests failed with exit code: $VITEST_EXIT_CODE"
              exit $VITEST_EXIT_CODE
            fi

  run-playwright-tests:
    description: "Run Playwright tests via the status service API and upload coverage"
    parameters:
      reason:
        type: string
        default: "Running Playwright tests"
    steps:
      - run:
          name: Run Playwright tests and upload coverage
          command: |
            # Support both FreegleDocker (~/project) and submodule (~/FreegleDocker) paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "üé≠ << parameters.reason >>..."

            # Trigger tests via API
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/playwright)
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger Playwright tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ Playwright tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring Playwright test progress..."
            start_time=$(date +%s)
            timeout_duration=2700  # 45 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚è∞ Playwright tests timed out after 45 minutes"
                exit 1
              fi

              sleep 10

              status_response=$(curl -s http://localhost:8081/api/tests/playwright/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')
              completed=$(echo "$status_response" | jq -r '.progress.completed // 0')
              total=$(echo "$status_response" | jq -r '.progress.total // 0')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status, Progress: $completed/$total tests"
              echo "Message: $message"

              if [ "$status" = "completed" ]; then
                success=$(echo "$status_response" | jq -r '.success // false')
                echo "üéâ Playwright tests completed! Success: $success"

                if [ "$success" = "true" ]; then
                  echo "‚úÖ All Playwright tests passed!"
                  echo "PLAYWRIGHT_TESTS_PASSED=true" >> $BASH_ENV
                  break
                else
                  echo "‚ùå Some Playwright tests failed!"
                  echo "Test logs:"
                  echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30
                  echo "PLAYWRIGHT_TESTS_PASSED=false" >> $BASH_ENV
                  exit 1
                fi
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå Playwright tests failed to run!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30
                echo "PLAYWRIGHT_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

            # Upload Playwright coverage immediately after tests complete
            echo "üì§ Uploading Playwright coverage..."
            if [ -z "${COVERALLS_REPO_TOKEN}" ]; then
              echo "‚ö†Ô∏è COVERALLS_REPO_TOKEN not set - skipping coverage upload"
              exit 0
            fi

            # Copy coverage file from playwright container (check multiple paths)
            LCOV_PATH=""
            if docker cp freegle-playwright:/app/monocart-report/coverage/lcov.info /tmp/playwright-coverage.lcov 2>/dev/null; then
              LCOV_PATH="/tmp/playwright-coverage.lcov"
              echo "‚úÖ Found Playwright coverage at /app/monocart-report/coverage/lcov.info"
            elif docker cp freegle-playwright:/app/coverage/lcov.info /tmp/playwright-coverage.lcov 2>/dev/null; then
              LCOV_PATH="/tmp/playwright-coverage.lcov"
              echo "‚úÖ Found Playwright coverage at /app/coverage/lcov.info"
            fi

            if [ -n "$LCOV_PATH" ]; then
              # Install coveralls
              npm install -g coveralls

              # Copy to original checkout if needed
              if [ -d ~/project/.git ]; then
                cp "$LCOV_PATH" ~/project/coverage.lcov
                cd ~/project
              fi

              export COVERALLS_SERVICE_NAME="circleci"
              export COVERALLS_SERVICE_JOB_ID="${CIRCLE_BUILD_NUM}"
              if cat "$LCOV_PATH" | coveralls; then
                echo "‚úÖ Playwright coverage uploaded successfully"
              else
                echo "‚ùå Playwright coverage upload failed"
                exit 1
              fi
            else
              echo "‚ùå Playwright coverage file not found"
              echo "Checking container for coverage files..."
              docker exec freegle-playwright find /app -name "*.lcov" -o -name "lcov.info" -o -name "coverage*" 2>/dev/null | head -20 || true
              exit 1
            fi
          no_output_timeout: 50m

  run-laravel-tests:
    description: "Run Laravel tests via the status service API and upload coverage"
    parameters:
      reason:
        type: string
        default: "Running Laravel tests"
    steps:
      - run:
          name: Run Laravel tests and upload coverage
          command: |
            # Support both FreegleDocker (~/project) and submodule (~/FreegleDocker) paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "üß™ << parameters.reason >>..."

            # Trigger tests via API
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" "http://localhost:8081/api/tests/laravel")
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger Laravel tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ Laravel tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring Laravel test progress..."
            start_time=$(date +%s)
            timeout_duration=1800  # 30 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Laravel tests timed out after 30 minutes"
                exit 1
              fi

              sleep 5
              status_response=$(curl -s http://localhost:8081/api/tests/laravel/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')
              passed=$(echo "$status_response" | jq -r '.progress.passed // 0')
              failed=$(echo "$status_response" | jq -r '.progress.failed // 0')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status | ${passed}‚úì ${failed}‚úó | $message"

              if [ "$status" = "completed" ]; then
                echo "üéâ Laravel tests completed!"
                echo "‚úÖ Laravel tests passed!"
                echo "LARAVEL_TESTS_PASSED=true" >> $BASH_ENV
                break
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå Laravel tests failed!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -50
                echo "LARAVEL_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

            # Upload Laravel coverage immediately after tests complete
            echo "üì§ Uploading Laravel coverage..."
            if [ -z "${COVERALLS_REPO_TOKEN}" ]; then
              echo "‚ö†Ô∏è COVERALLS_REPO_TOKEN not set - skipping coverage upload"
              exit 0
            fi

            # Copy coverage file from container
            if docker cp freegle-batch:/tmp/laravel-coverage.xml /tmp/laravel-clover.xml 2>/dev/null; then
              echo "‚úÖ Found Laravel coverage file ($(stat -f%z /tmp/laravel-clover.xml 2>/dev/null || stat -c%s /tmp/laravel-clover.xml) bytes)"

              # Install php-coveralls
              npm install -g coveralls
              docker exec freegle-apiv1 bash -c "cd /var/www/iznik && php composer.phar require php-coveralls/php-coveralls --dev" || echo "php-coveralls install warning"

              # Copy coverage file to container and upload
              docker cp /tmp/laravel-clover.xml freegle-apiv1:/var/www/iznik/clover.xml
              docker exec freegle-apiv1 bash -c "cd /var/www/iznik && COVERALLS_REPO_TOKEN=${COVERALLS_REPO_TOKEN} COVERALLS_SERVICE_NAME=circleci COVERALLS_SERVICE_JOB_ID=${CIRCLE_BUILD_NUM} vendor/bin/php-coveralls -v --coverage_clover=clover.xml --json_path=/tmp/coveralls.json"

              if [ $? -eq 0 ]; then
                echo "‚úÖ Laravel coverage uploaded successfully"
              else
                echo "‚ùå Laravel coverage upload failed"
                exit 1
              fi
            else
              echo "‚ùå Laravel coverage file not found at /tmp/laravel-coverage.xml"
              exit 1
            fi
          no_output_timeout: 35m

  # === Artifact Collection ===

  collect-artifacts:
    description: "Collect build artifacts and logs"
    steps:
      - run:
          name: Collect artifacts
          command: |
            mkdir -p ~/artifacts

            # Support both FreegleDocker main build and submodule paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi

            # Collect Docker logs
            if docker-compose -f docker-compose.yml ps > /dev/null 2>&1; then
              docker-compose -f docker-compose.yml logs > ~/artifacts/docker-logs.txt 2>&1 || true
              docker-compose -f docker-compose.yml ps > ~/artifacts/docker-status.txt 2>&1 || true
            fi

            # Use fixed container names from docker-compose.yml (no dynamic lookup needed)

            # Collect PHPUnit test output files
            mkdir -p ~/artifacts/phpunit
            docker cp freegle-apiv1-phpunit:/tmp/phpunit-output.log ~/artifacts/phpunit/ 2>/dev/null || true
            docker cp freegle-apiv1-phpunit:/tmp/phpunit-debug.log ~/artifacts/phpunit/ 2>/dev/null || true

            # Collect Laravel (batch) test output and monitoring logs
            mkdir -p ~/artifacts/laravel
            docker cp freegle-status:/tmp/laravel-bootstrap-cache-monitor.log ~/artifacts/laravel/ 2>/dev/null || true
            docker cp freegle-batch:/tmp/bootstrap-cache-monitor.log ~/artifacts/laravel/inotify-raw.log 2>/dev/null || true
            docker cp freegle-batch:/tmp/laravel-coverage.xml ~/artifacts/laravel/ 2>/dev/null || true

            # Collect Go test coverage
            mkdir -p ~/artifacts/go
            docker cp freegle-apiv2:/app/coverage.out ~/artifacts/go/ 2>/dev/null || true
            docker cp freegle-apiv2:/app/coverage.html ~/artifacts/go/ 2>/dev/null || true

            # Collect Playwright test artifacts
            # Copy the entire playwright-report folder to artifacts root so HTML can find its data/ subfolder
            echo "=== Collecting Playwright artifacts ==="

            # Check if container is running
            if docker ps --format '{{.Names}}' | grep -q '^freegle-playwright$'; then
              echo "‚úì Playwright container is running"

              # List what's in the playwright-report directory
              echo "Contents of /app/playwright-report:"
              docker exec freegle-playwright ls -la /app/playwright-report 2>&1 || echo "  (directory not accessible)"

              # Copy playwright-report
              if docker cp freegle-playwright:/app/playwright-report ~/artifacts/ 2>&1; then
                echo "‚úì Copied playwright-report"
                ls -la ~/artifacts/playwright-report/ 2>&1 | head -10
              else
                echo "‚úó Failed to copy playwright-report"
              fi

              # Copy test-results
              if docker cp freegle-playwright:/app/test-results ~/artifacts/ 2>&1; then
                echo "‚úì Copied test-results"
              else
                echo "‚úó Failed to copy test-results"
              fi
            else
              echo "‚úó Playwright container is not running - cannot collect artifacts"
              echo "Container status:"
              docker ps -a --filter "name=playwright" --format "table {{.Names}}\t{{.Status}}"
            fi

            # Build info
            echo "CircleCI Build: $CIRCLE_BUILD_NUM" > ~/artifacts/build-info.txt
            echo "Branch: $CIRCLE_BRANCH" >> ~/artifacts/build-info.txt
            date >> ~/artifacts/build-info.txt
          when: always
      - store_artifacts:
          path: ~/artifacts

  upload-coverage:
    description: "Upload coverage reports to Coveralls"
    parameters:
      expected:
        type: string
        default: ""
        description: "Comma-separated list of expected coverage types (go,php,playwright). If specified, missing coverage is a failure."
    steps:
      - run:
          name: Check coverage prerequisites
          command: |
            EXPECTED_COVERAGE="<< parameters.expected >>"
            if [ -z "${COVERALLS_REPO_TOKEN}" ]; then
              if [ -n "$EXPECTED_COVERAGE" ]; then
                echo "‚ùå COVERALLS_REPO_TOKEN not set but coverage is expected: $EXPECTED_COVERAGE"
                exit 1
              fi
              echo "‚ö†Ô∏è COVERALLS_REPO_TOKEN not set - skipping coverage upload"
              echo "SKIP_COVERAGE=true" >> $BASH_ENV
            else
              npm install -g coveralls
              echo "GO_UPLOADED=false" >> $BASH_ENV
              echo "PHP_UPLOADED=false" >> $BASH_ENV
              echo "PLAYWRIGHT_UPLOADED=false" >> $BASH_ENV
              echo "LARAVEL_UPLOADED=false" >> $BASH_ENV
            fi
          when: always
      - run:
          name: Upload Go coverage
          command: |
            if [ "$SKIP_COVERAGE" = "true" ]; then exit 0; fi
            # Support both FreegleDocker main build and submodule paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            echo "Working directory: $(pwd)"
            echo "Docker-compose services:"
            docker-compose -f docker-compose.yml ps || echo "docker-compose ps failed"
            # Use fixed container name from docker-compose.yml
            if docker cp freegle-apiv2:/app/coverage.out iznik-server-go/coverage.out 2>/dev/null; then
              echo "Found Go coverage..."
              go install github.com/jandelgado/gcov2lcov@latest || true
              if command -v gcov2lcov > /dev/null; then
                cd iznik-server-go
                if gcov2lcov -infile=coverage.out -outfile=coverage.lcov 2>&1 && [ -s coverage.lcov ]; then
                  # Copy lcov to original checkout for coveralls (needs .git)
                  if [ -d ~/project/.git ]; then
                    cp coverage.lcov ~/project/
                    cd ~/project
                  else
                    cd ..
                  fi
                  export COVERALLS_SERVICE_NAME="circleci"
                  export COVERALLS_SERVICE_JOB_ID="${CIRCLE_BUILD_NUM}"
                  if cat coverage.lcov | coveralls; then
                    echo "‚úÖ Go coverage uploaded"
                    echo "GO_UPLOADED=true" >> $BASH_ENV
                  else
                    echo "‚ùå Go coverage upload failed"
                    exit 1
                  fi
                else
                  echo "‚ùå Failed to convert Go coverage to lcov format"
                  cd ..
                  exit 1
                fi
              else
                echo "‚ùå gcov2lcov not found"
                exit 1
              fi
            else
              echo "‚ÑπÔ∏è No Go coverage found (this is OK if Go tests didn't run)"
            fi
          when: always
      - run:
          name: Upload PHP coverage
          command: |
            if [ "$SKIP_COVERAGE" = "true" ]; then exit 0; fi
            # Support both FreegleDocker main build and submodule paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            # Use fixed container name from docker-compose.yml
            COVERAGE_FOUND=false

            # Try the standard test path first (used by PR tests)
            if docker cp freegle-apiv1-phpunit:/var/www/iznik/test/ut/php/clover.xml /tmp/phpunit-clover.xml 2>/dev/null; then
              COVERAGE_FOUND=true
              echo "Found PHP coverage at /var/www/iznik/test/ut/php/clover.xml"
            # Also try /tmp/phpunit-coverage.xml (used by status service when running via API)
            elif docker cp freegle-apiv1-phpunit:/tmp/phpunit-coverage.xml /tmp/phpunit-clover.xml 2>/dev/null; then
              COVERAGE_FOUND=true
              echo "Found PHP coverage at /tmp/phpunit-coverage.xml"
            fi

            if [ "$COVERAGE_FOUND" = "true" ]; then
              echo "Processing PHP coverage..."

              # Install php-coveralls in the container using composer.phar
              docker exec freegle-apiv1 bash -c "cd /var/www/iznik && php composer.phar require php-coveralls/php-coveralls --dev 2>&1" || true

              # Copy coverage file to container
              docker cp /tmp/phpunit-clover.xml freegle-apiv1:/var/www/iznik/clover.xml

              # Create coveralls config in container with writable json_path
              docker exec freegle-apiv1 bash -c "echo 'coverage_clover: clover.xml' > /var/www/iznik/.coveralls.yml && echo 'json_path: /tmp/coveralls-upload.json' >> /var/www/iznik/.coveralls.yml && echo 'service_name: circleci' >> /var/www/iznik/.coveralls.yml"

              # Initialize a minimal git repo in container for php-coveralls (it needs git info)
              # The submodule's .git file points to a path not mounted in container
              # Must create an initial commit so there's a branch for collectBranch()
              docker exec freegle-apiv1 bash -c "cd /var/www/iznik && rm -f .git && git init && git config user.email 'ci@freegle.org' && git config user.name 'CircleCI' && git remote add origin https://github.com/Freegle/iznik-server.git && git commit --allow-empty -m 'CI initial commit' && git branch -M $CIRCLE_BRANCH"

              # Run php-coveralls from within the container (which has PHP)
              # Note: Uses COVERALLS_REPO_TOKEN_IZNIK_SERVER for iznik-server repo
              # Pass git info via environment variables since container doesn't have access to .git/modules
              if docker exec \
                -e COVERALLS_REPO_TOKEN="$COVERALLS_REPO_TOKEN_IZNIK_SERVER" \
                -e COVERALLS_RUN_LOCALLY=1 \
                -e CI_BRANCH="$CIRCLE_BRANCH" \
                -e CI_COMMIT_ID="$CIRCLE_SHA1" \
                -e CI_BUILD_NUMBER="$CIRCLE_BUILD_NUM" \
                -e CI_BUILD_URL="$CIRCLE_BUILD_URL" \
                -e CI_NAME="circleci" \
                freegle-apiv1 bash -c "cd /var/www/iznik && php composer/vendor/bin/php-coveralls -v --config .coveralls.yml --exclude-no-stmt 2>&1"; then
                echo "‚úÖ PHP coverage uploaded"
                echo "PHP_UPLOADED=true" >> $BASH_ENV
              else
                echo "‚ùå PHP coverage upload failed"
                exit 1
              fi
            else
              echo "‚ÑπÔ∏è No PHP coverage found at either location"
            fi
          when: always
      - run:
          name: Upload Playwright coverage
          command: |
            if [ "$SKIP_COVERAGE" = "true" ]; then exit 0; fi
            # Support both FreegleDocker main build and submodule paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi
            # Use fixed container name from docker-compose.yml
            LCOV_PATH=""
            if docker cp freegle-playwright:/app/coverage/lcov.info /tmp/playwright-coverage.lcov 2>/dev/null; then
              LCOV_PATH="/tmp/playwright-coverage.lcov"
            elif docker cp freegle-playwright:/app/monocart-report/coverage/lcov.info /tmp/playwright-coverage.lcov 2>/dev/null; then
              LCOV_PATH="/tmp/playwright-coverage.lcov"
            fi
            if [ -n "$LCOV_PATH" ]; then
              echo "Found Playwright coverage..."
              export COVERALLS_SERVICE_NAME="circleci"
              export COVERALLS_SERVICE_JOB_ID="${CIRCLE_BUILD_NUM}"
              # Run from original checkout for git metadata
              if [ -d ~/project/.git ]; then
                cp "$LCOV_PATH" ~/project/coverage.lcov
                cd ~/project
                if cat coverage.lcov | coveralls; then
                  echo "‚úÖ Playwright coverage uploaded"
                  echo "PLAYWRIGHT_UPLOADED=true" >> $BASH_ENV
                else
                  echo "‚ùå Playwright coverage upload failed"
                  exit 1
                fi
              else
                if cat "$LCOV_PATH" | coveralls; then
                  echo "‚úÖ Playwright coverage uploaded"
                  echo "PLAYWRIGHT_UPLOADED=true" >> $BASH_ENV
                else
                  echo "‚ùå Playwright coverage upload failed"
                  exit 1
                fi
              fi
            else
              echo "‚ÑπÔ∏è No Playwright coverage found (this is OK if Playwright tests didn't run)"
            fi
          when: always
      - run:
          name: Upload Laravel coverage
          command: |
            if [ "$SKIP_COVERAGE" = "true" ]; then exit 0; fi
            # Support both FreegleDocker main build and submodule paths
            if [ -d "$HOME/FreegleDocker" ]; then
              cd "$HOME/FreegleDocker"
            fi

            # Copy Laravel coverage from batch container
            if docker cp freegle-batch:/tmp/laravel-coverage.xml /tmp/laravel-clover.xml 2>/dev/null; then
              echo "Found Laravel coverage..."

              # Run php-coveralls from inside the batch container which has PHP
              # Copy the coverage file and run coveralls from there
              docker cp /tmp/laravel-clover.xml freegle-batch:/var/www/html/clover.xml

              # Create coveralls config in container
              docker exec freegle-batch bash -c "cd /var/www/html && echo 'coverage_clover: clover.xml' > .coveralls.yml && echo 'json_path: /tmp/coveralls-upload.json' >> .coveralls.yml && echo 'service_name: circleci' >> .coveralls.yml"

              # Install php-coveralls in the batch container
              echo "Installing php-coveralls in batch container..."
              if ! docker exec freegle-batch composer require php-coveralls/php-coveralls --dev 2>&1; then
                echo "‚ùå Could not install php-coveralls in batch container"
                exit 1
              fi

              # Initialize git repo in container (php-coveralls needs it for git info including remotes)
              echo "Initializing git repo in container for php-coveralls..."
              docker exec freegle-batch bash -c "cd /var/www/html && git config --global --add safe.directory /var/www/html && git init && git config user.email 'circleci@freegle.org' && git config user.name 'CircleCI' && git remote add origin https://github.com/Freegle/FreegleDocker.git && git add -A && git commit -m 'CI commit' --allow-empty" 2>/dev/null || true

              # Run php-coveralls from within the container
              # Note: Uses main COVERALLS_REPO_TOKEN since iznik-batch is part of FreegleDocker
              if docker exec -e COVERALLS_REPO_TOKEN="$COVERALLS_REPO_TOKEN" \
                 -e COVERALLS_RUN_LOCALLY=1 \
                 -e CI_NAME=circleci \
                 -e CI_BUILD_NUMBER="$CIRCLE_BUILD_NUM" \
                 -e CI_BRANCH="$CIRCLE_BRANCH" \
                 -e CI_COMMIT_ID="$CIRCLE_SHA1" \
                 freegle-batch bash -c "cd /var/www/html && vendor/bin/php-coveralls -v --config .coveralls.yml 2>&1"; then
                echo "‚úÖ Laravel coverage uploaded"
                echo "LARAVEL_UPLOADED=true" >> $BASH_ENV
              else
                echo "‚ùå Laravel coverage upload failed"
                docker exec freegle-batch ls -la /var/www/html/vendor/bin/ 2>&1 || true
                exit 1
              fi
            else
              echo "‚ÑπÔ∏è No Laravel coverage found at /tmp/laravel-coverage.xml (this is OK if Laravel tests didn't run)"
            fi
          when: always
      - run:
          name: Validate expected coverage
          command: |
            if [ "$SKIP_COVERAGE" = "true" ]; then exit 0; fi
            EXPECTED="<< parameters.expected >>"
            if [ -z "$EXPECTED" ]; then exit 0; fi
            echo "üìã Validating expected coverage: $EXPECTED"
            MISSING=""
            IFS=',' read -ra TYPES \<<< "$EXPECTED"
            for t in "${TYPES[@]}"; do
              t=$(echo "$t" | xargs)
              case "$t" in
                go) [ "$GO_UPLOADED" != "true" ] && MISSING="$MISSING go" ;;
                php) [ "$PHP_UPLOADED" != "true" ] && MISSING="$MISSING php" ;;
                playwright) [ "$PLAYWRIGHT_UPLOADED" != "true" ] && MISSING="$MISSING playwright" ;;
                laravel) [ "$LARAVEL_UPLOADED" != "true" ] && MISSING="$MISSING laravel" ;;
              esac
            done
            if [ -n "$MISSING" ]; then
              echo "‚ùå Missing expected coverage:$MISSING"
              exit 1
            fi
            echo "‚úÖ All expected coverage uploaded"
          when: always

  # === App Build Commands ===

  setup-android-fastlane:
    description: "Install Ruby, Bundler, and Fastlane for Android builds"
    steps:
      - run:
          name: Install Ruby and Bundler
          command: |
            sudo apt-get update
            sudo apt-get install -y ruby-full
            sudo gem install bundler
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Install Fastlane
          command: |
            bundle config set --local path 'vendor/bundle'
            bundle update fastlane
            bundle install
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Decode Google Play JSON Key
          command: |
            echo "üîê Decoding Google Play JSON Key..."

            if [ -z "$GOOGLE_PLAY_JSON_KEY" ]; then
              echo "‚ùå CRITICAL: GOOGLE_PLAY_JSON_KEY environment variable is not set"
              exit 1
            fi

            echo $GOOGLE_PLAY_JSON_KEY | base64 -d > fastlane/google-play-api-key.json

            if [ ! -f fastlane/google-play-api-key.json ]; then
              echo "‚ùå CRITICAL: Failed to create google-play-api-key.json"
              exit 1
            fi

            FILE_SIZE=$(wc -c < fastlane/google-play-api-key.json)
            echo "‚úÖ File created: $FILE_SIZE bytes"

            if [ "$FILE_SIZE" -eq 0 ]; then
              echo "‚ùå CRITICAL: google-play-api-key.json is empty"
              exit 1
            fi

            if python3 -m json.tool fastlane/google-play-api-key.json > /dev/null 2>&1; then
              echo "‚úÖ Valid JSON structure"
              echo "üìß Service Account: $(python3 -c "import json; print(json.load(open('fastlane/google-play-api-key.json'))['client_email'])")"
            else
              echo "‚ùå CRITICAL: Invalid JSON - Google Play API will not work!"
              exit 1
            fi

            echo "‚úÖ Google Play JSON Key validated successfully"

jobs:
  # === Submodule PR Test Jobs ===

  php-tests:
    executor: machine-executor
    steps:
      - checkout
      - setup-dependencies
      - clone-freegle-docker
      - replace-submodule:
          submodule: "iznik-server"
      - start-services
      - wait-for-basic-services
      - run-php-tests:
          reason: "Running PHPUnit tests for PR"
      # Coverage uploaded inline by status API
      - collect-artifacts

  go-tests:
    executor: machine-executor
    steps:
      - checkout
      - setup-dependencies
      - clone-freegle-docker
      - replace-submodule:
          submodule: "iznik-server-go"
      - build-submodule-container:
          container: "apiv2"
      - start-services
      - wait-for-basic-services
      - run-go-tests:
          reason: "Running Go tests for PR"
      # Coverage uploaded inline by status API
      - collect-artifacts

  playwright-tests:
    executor: machine-executor
    steps:
      - checkout
      - setup-dependencies
      - clone-freegle-docker
      - replace-submodule:
          submodule: "iznik-nuxt3"
      # Run Vitest unit tests first (doesn't need Docker services)
      - run-vitest-tests:
          reason: "Running Vitest unit tests for PR"
      - start-services
      - wait-for-basic-services
      - wait-for-prod-container
      - wait-for-batch-container
      - setup-test-database
      - run-playwright-tests:
          reason: "Running Playwright tests for PR"
      # Coverage uploaded inline by status API
      - collect-artifacts

  # === FreegleDocker Main Build Job ===

  build-and-test:
    executor: machine-executor
    steps:
      # Fix ownership of root-owned files BEFORE checkout so git can write
      - run:
          name: Fix file ownership before checkout
          command: |
            # Docker creates files with root ownership that git checkout can't overwrite
            echo "Fixing file ownership..."
            sudo chown -R $(id -u):$(id -g) . 2>/dev/null || true
            echo "Ownership fixed"

      - checkout

      - run:
          name: Pre-create runtime directories
          command: |
            # Pre-create directories with correct ownership so Docker doesn't create them as root
            mkdir -p ssl/certs logs data status/data test-results

      - run:
          name: Check if only plans or yesterday files changed
          command: |
            if [ "$CIRCLE_BRANCH" = "master" ]; then
              CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD)
            else
              CHANGED_FILES=$(git diff --name-only origin/master...HEAD)
            fi

            if [ -n "$CHANGED_FILES" ]; then
              NON_SKIPPABLE_FILES=$(echo "$CHANGED_FILES" | grep -v -E '^(plans/|yesterday/)' || true)
              if [ -z "$NON_SKIPPABLE_FILES" ]; then
                echo "Only plans/ or yesterday/ files were changed. Skipping build."
                circleci-agent step halt
              fi
            fi

      - run:
          name: Initialize and update git submodules
          command: |
            git submodule init
            git submodule update --recursive --jobs 4
            git submodule status

            # ModTools is now built from iznik-nuxt3/modtools (same repo, different build)
            echo "=== Verifying modtools directory ==="
            ls -la iznik-nuxt3/modtools/Dockerfile* || echo "WARNING: modtools/Dockerfile files not found"

      - setup-dependencies

      - start-docker-services:
          reason: "Starting all Docker services"

      - wait-for-basic-services

      - wait-for-prod-container

      # Wait for batch container migrations to complete BEFORE loading schema.sql
      # This prevents race conditions where schema.sql's DROP TABLE statements interfere with
      # migrations that are still running.
      - wait-for-batch-container
      - setup-test-database

      # Run Vitest unit tests first (fast, fail-fast before slower tests)
      - run-vitest-tests:
          reason: "Running Vitest unit tests (fail-fast before parallel tests)"

      # Run iznik-batch, Playwright, Go, and iznik-server tests in parallel via status API
      - run:
          name: Run iznik-batch, Playwright, Go, and iznik-server tests in parallel
          command: |
            echo "üöÄ Running all tests in parallel via status API..."
            mkdir -p ~/test-output
            TESTS_KILLED_EARLY=false

            # === WATCHDOG TIMEOUT ===
            # Start a watchdog that will force-stop tests after 48 minutes
            # This leaves ~12 minutes for artifact collection before CircleCI's 60-min hard limit
            WATCHDOG_TIMEOUT_MINUTES=48
            echo "‚è±Ô∏è Starting watchdog timer (${WATCHDOG_TIMEOUT_MINUTES} minutes)..."
            (
              sleep $((WATCHDOG_TIMEOUT_MINUTES * 60))
              echo "‚è∞ WATCHDOG: ${WATCHDOG_TIMEOUT_MINUTES}-minute timeout reached!"
              echo "timeout" > /tmp/watchdog-triggered
              # Kill all background test processes
              pkill -f "curl.*localhost:8081/api/tests" 2>/dev/null || true
              # Signal the main process to check the marker
              kill -USR1 $$ 2>/dev/null || true
            ) &
            WATCHDOG_PID=$!
            echo "WATCHDOG_PID=$WATCHDOG_PID" > /tmp/watchdog-pid

            # Trap to check watchdog on signal
            trap 'if [ -f /tmp/watchdog-triggered ]; then echo "‚è∞ Tests terminated by watchdog timeout"; fi' USR1

            # Start iznik-batch tests in background
            echo "üß™ Starting iznik-batch tests in background..."
            (
              # Trigger Laravel tests via status API
              response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/laravel)
              http_code="${response: -3}"

              if [ "$http_code" = "409" ]; then
                echo "‚ö†Ô∏è iznik-batch tests already running (HTTP 409) - joining existing run"
              elif [ "$http_code" -ne "200" ]; then
                echo "‚ùå Failed to trigger iznik-batch tests. HTTP code: $http_code"
                echo "fail" > /tmp/laravel-result
                echo "0" > /tmp/laravel-completed
                echo "0" > /tmp/laravel-total
                exit 1
              else
                echo "‚úÖ iznik-batch tests triggered successfully"
              fi

              # Mark as running so fail-fast can detect killed tests
              echo "running" > /tmp/laravel-result

              # Poll for Laravel completion
              while true; do
                sleep 10
                status_response=$(curl -s http://localhost:8081/api/tests/laravel/status || echo '{"status":"error"}')
                status=$(echo "$status_response" | jq -r '.status // "unknown"')

                # Extract progress for display
                completed=$(echo "$status_response" | jq -r '.progress.completed // 0')
                total=$(echo "$status_response" | jq -r '.progress.total // 0')
                echo "$completed" > /tmp/laravel-completed
                echo "$total" > /tmp/laravel-total

                if [ "$status" = "completed" ]; then
                  echo "pass" > /tmp/laravel-result
                  echo "‚úÖ iznik-batch tests passed!"
                  break
                elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                  echo "fail" > /tmp/laravel-result
                  echo "‚ùå iznik-batch tests failed!"
                  echo "$status_response" | jq -r '.logs // "No logs"'
                  break
                fi
              done
            ) > ~/test-output/laravel.out 2>&1 &
            LARAVEL_PID=$!

            # Start Go tests in background
            echo "üß™ Starting Go tests in background..."
            (
              # Trigger Go tests via status API
              response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/go)
              http_code="${response: -3}"

              if [ "$http_code" = "409" ]; then
                echo "‚ö†Ô∏è Go tests already running (HTTP 409) - joining existing run"
              elif [ "$http_code" -ne "200" ]; then
                echo "‚ùå Failed to trigger Go tests. HTTP code: $http_code"
                echo "fail" > /tmp/go-result
                echo "0" > /tmp/go-completed
                echo "0" > /tmp/go-total
                exit 1
              else
                echo "‚úÖ Go tests triggered successfully"
              fi

              # Mark as running so fail-fast can detect killed tests
              echo "running" > /tmp/go-result

              # Poll for Go completion
              while true; do
                sleep 10
                status_response=$(curl -s http://localhost:8081/api/tests/go/status || echo '{"status":"error"}')
                status=$(echo "$status_response" | jq -r '.status // "unknown"')

                # Extract progress for display
                completed=$(echo "$status_response" | jq -r '.progress.completed // 0')
                total=$(echo "$status_response" | jq -r '.progress.total // 0')
                echo "$completed" > /tmp/go-completed
                echo "$total" > /tmp/go-total

                if [ "$status" = "completed" ]; then
                  echo "pass" > /tmp/go-result
                  echo "‚úÖ Go tests passed!"
                  break
                elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                  echo "fail" > /tmp/go-result
                  echo "‚ùå Go tests failed!"
                  echo "$status_response" | jq -r '.logs // "No logs"'
                  break
                fi
              done
            ) > ~/test-output/go.out 2>&1 &
            GO_PID=$!

            # Start iznik-server tests in background (uses separate iznik_phpunit_test database)
            echo "üß™ Starting iznik-server tests in background..."
            (
              # Restore GeoIP database from cache if available
              if [ -f ~/geoip-cache/GeoLite2-Country.mmdb ]; then
                echo "üìç Restoring GeoIP database from cache..."
                docker exec freegle-apiv1-phpunit mkdir -p /var/lib/GeoIP
                docker cp ~/geoip-cache/GeoLite2-Country.mmdb freegle-apiv1-phpunit:/var/lib/GeoIP/GeoLite2-Country.mmdb
                docker cp ~/geoip-cache/GeoLite2-City.mmdb freegle-apiv1-phpunit:/var/lib/GeoIP/GeoLite2-City.mmdb 2>/dev/null || true
              fi

              # Trigger PHPUnit tests via API
              response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/php)
              http_code="${response: -3}"

              if [ "$http_code" = "409" ]; then
                echo "‚ö†Ô∏è PHP tests already running (HTTP 409) - joining existing run"
              elif [ "$http_code" -ne "200" ]; then
                echo "‚ùå Failed to trigger PHP tests. HTTP code: $http_code"
                echo "fail" > /tmp/php-result
                echo "0" > /tmp/php-completed
                echo "0" > /tmp/php-total
                exit 1
              else
                echo "‚úÖ PHP tests triggered successfully"
              fi

              # Mark as running so fail-fast can detect killed tests
              echo "running" > /tmp/php-result

              # Poll for PHPUnit completion
              while true; do
                sleep 10
                status_response=$(curl -s http://localhost:8081/api/tests/php/status || echo '{"status":"error"}')
                status=$(echo "$status_response" | jq -r '.status // "unknown"')
                # Extract progress counts for display
                completed=$(echo "$status_response" | jq -r '.progress.completed // 0')
                total=$(echo "$status_response" | jq -r '.progress.total // 0')
                echo "$completed" > /tmp/php-completed
                echo "$total" > /tmp/php-total


                if [ "$status" = "completed" ]; then
                  echo "pass" > /tmp/php-result
                  echo "‚úÖ iznik-server tests passed!"
                  break
                elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                  echo "fail" > /tmp/php-result
                  echo "‚ùå iznik-server tests failed!"
                  # Get the logs for the output file
                  echo "$status_response" | jq -r '.logs // "No logs"'
                  break
                fi
              done
            ) > ~/test-output/phpunit.out 2>&1 &
            PHPUNIT_PID=$!

            # Start Playwright tests in background
            echo "üé≠ Starting Playwright tests in background..."
            (
              # Trigger Playwright tests via status API
              response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/playwright)
              http_code="${response: -3}"

              if [ "$http_code" = "409" ]; then
                echo "‚ö†Ô∏è Playwright tests already running (HTTP 409) - joining existing run"
              elif [ "$http_code" -ne "200" ]; then
                echo "‚ùå Failed to trigger Playwright tests. HTTP code: $http_code"
                echo "fail" > /tmp/playwright-result
                # Initialize progress files for display
                echo "0" > /tmp/playwright-completed
                echo "0" > /tmp/playwright-total
                exit 1
              else
                echo "‚úÖ Playwright tests triggered successfully"
              fi

              # Mark as running so fail-fast can detect killed tests
              echo "running" > /tmp/playwright-result

              # Poll for completion
              while true; do
                sleep 10
                status_response=$(curl -s http://localhost:8081/api/tests/playwright/status || echo '{"status":"error"}')
                status=$(echo "$status_response" | jq -r '.status // "unknown"')
                completed=$(echo "$status_response" | jq -r '.progress.completed // 0')
                total=$(echo "$status_response" | jq -r '.progress.total // 0')

                # Update progress files
                echo "$completed" > /tmp/playwright-completed
                echo "$total" > /tmp/playwright-total

                if [ "$status" = "completed" ]; then
                  success=$(echo "$status_response" | jq -r '.success // false')
                  if [ "$success" = "true" ]; then
                    echo "pass" > /tmp/playwright-result
                  else
                    echo "fail" > /tmp/playwright-result
                    # Get the logs for the output file
                    echo "$status_response" | jq -r '.logs // "No logs"'
                  fi
                  break
                elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                  echo "fail" > /tmp/playwright-result
                  echo "$status_response" | jq -r '.logs // "No logs"'
                  break
                fi
              done
            ) > ~/test-output/playwright.out 2>&1 &
            PLAYWRIGHT_PID=$!

            # Unified monitoring loop for all 4 tests
            echo "üìä Monitoring all tests..."
            start_time=$(date +%s)
            timeout_duration=2700  # 45 minutes
            TESTS_KILLED_EARLY=false

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              elapsed_min=$((elapsed / 60))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚è∞ Tests timed out after 45 minutes"
                kill $LARAVEL_PID $GO_PID $PHPUNIT_PID $PLAYWRIGHT_PID 2>/dev/null || true
                TESTS_KILLED_EARLY=true
                break
              fi

              # Check if watchdog triggered (overall job timeout approaching)
              if [ -f /tmp/watchdog-triggered ]; then
                echo "‚è∞ WATCHDOG: Overall job timeout - stopping tests to collect artifacts"
                echo "timeout" > /tmp/playwright-result
                kill $LARAVEL_PID 2>/dev/null || true
                kill $GO_PID 2>/dev/null || true
                kill $PHPUNIT_PID 2>/dev/null || true
                TESTS_KILLED_EARLY=true
                break
              fi

              sleep 10

              status_response=$(curl -s http://localhost:8081/api/tests/playwright/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              completed=$(echo "$status_response" | jq -r '.progress.completed // 0')
              total=$(echo "$status_response" | jq -r '.progress.total // 0')

              elapsed_min=$((elapsed / 60))
              LARAVEL_STATUS=$([ -f /tmp/laravel-result ] && cat /tmp/laravel-result || echo 'running')
              LARAVEL_COMPLETED=$([ -f /tmp/laravel-completed ] && cat /tmp/laravel-completed || echo '0')
              LARAVEL_TOTAL=$([ -f /tmp/laravel-total ] && cat /tmp/laravel-total || echo '0')
              LARAVEL_DISPLAY=$([ "$LARAVEL_STATUS" = "running" ] && echo "running ($LARAVEL_COMPLETED/$LARAVEL_TOTAL)" || echo "$LARAVEL_STATUS")

              GO_STATUS=$([ -f /tmp/go-result ] && cat /tmp/go-result || echo 'running')
              GO_COMPLETED=$([ -f /tmp/go-completed ] && cat /tmp/go-completed || echo '0')
              GO_TOTAL=$([ -f /tmp/go-total ] && cat /tmp/go-total || echo '0')
              # Go doesn't have a pre-count, so show just completed when total is 0
              if [ "$GO_STATUS" = "running" ]; then
                if [ "$GO_TOTAL" -gt 0 ]; then
                  GO_DISPLAY="running ($GO_COMPLETED/$GO_TOTAL)"
                else
                  GO_DISPLAY="running ($GO_COMPLETED)"
                fi
              else
                GO_DISPLAY="$GO_STATUS"
              fi

              PHP_STATUS=$([ -f /tmp/php-result ] && cat /tmp/php-result || echo 'running')
              PHP_COMPLETED=$([ -f /tmp/php-completed ] && cat /tmp/php-completed || echo '0')
              PHP_TOTAL=$([ -f /tmp/php-total ] && cat /tmp/php-total || echo '0')
              PHP_DISPLAY=$([ "$PHP_STATUS" = "running" ] && echo "running ($PHP_COMPLETED/$PHP_TOTAL)" || echo "$PHP_STATUS")

              PLAYWRIGHT_STATUS=$([ -f /tmp/playwright-result ] && cat /tmp/playwright-result || echo 'running')
              PLAYWRIGHT_COMPLETED=$([ -f /tmp/playwright-completed ] && cat /tmp/playwright-completed || echo '0')
              PLAYWRIGHT_TOTAL=$([ -f /tmp/playwright-total ] && cat /tmp/playwright-total || echo '0')
              # Cap completed at total for display (symbol counting can double-count at end)
              if [ "$PLAYWRIGHT_STATUS" = "running" ]; then
                if [ "$PLAYWRIGHT_TOTAL" -gt 0 ] && [ "$PLAYWRIGHT_COMPLETED" -gt "$PLAYWRIGHT_TOTAL" ]; then
                  PLAYWRIGHT_DISPLAY="running ($PLAYWRIGHT_TOTAL/$PLAYWRIGHT_TOTAL)"
                else
                  PLAYWRIGHT_DISPLAY="running ($PLAYWRIGHT_COMPLETED/$PLAYWRIGHT_TOTAL)"
                fi
              else
                PLAYWRIGHT_DISPLAY="$PLAYWRIGHT_STATUS"
              fi

              echo "[${elapsed_min}m] iznik-batch: $LARAVEL_DISPLAY | Go: $GO_DISPLAY | iznik-server: $PHP_DISPLAY | Playwright: $PLAYWRIGHT_DISPLAY"

              # Check for any failures (fail-fast)
              if [ "$LARAVEL_STATUS" = "fail" ]; then
                echo "‚ùå FAIL-FAST: iznik-batch tests failed - stopping all tests"
                kill $GO_PID $PHPUNIT_PID $PLAYWRIGHT_PID 2>/dev/null || true
                TESTS_KILLED_EARLY=true
                break
              fi
              if [ "$GO_STATUS" = "fail" ]; then
                echo "‚ùå FAIL-FAST: Go tests failed - stopping all tests"
                kill $LARAVEL_PID $PHPUNIT_PID $PLAYWRIGHT_PID 2>/dev/null || true
                TESTS_KILLED_EARLY=true
                break
              fi
              if [ "$PHP_STATUS" = "fail" ]; then
                echo "‚ùå FAIL-FAST: iznik-server tests failed - stopping all tests"
                kill $LARAVEL_PID $GO_PID $PLAYWRIGHT_PID 2>/dev/null || true
                TESTS_KILLED_EARLY=true
                break
              fi
              if [ "$PLAYWRIGHT_STATUS" = "fail" ]; then
                echo "‚ùå FAIL-FAST: Playwright tests failed - stopping all tests"
                kill $LARAVEL_PID $GO_PID $PHPUNIT_PID 2>/dev/null || true
                TESTS_KILLED_EARLY=true
                break
              fi

              # Check if all tests completed
              if [ "$LARAVEL_STATUS" != "running" ] && [ "$GO_STATUS" != "running" ] && [ "$PHP_STATUS" != "running" ] && [ "$PLAYWRIGHT_STATUS" != "running" ]; then
                echo "‚úÖ All tests completed"
                break
              fi

              sleep 10
            done

            # Wait for all background processes to finish
            wait $LARAVEL_PID 2>/dev/null || true
            wait $GO_PID 2>/dev/null || true
            wait $PHPUNIT_PID 2>/dev/null || true
            wait $PLAYWRIGHT_PID 2>/dev/null || true

            # Check results from files
            LARAVEL_RESULT=$(cat /tmp/laravel-result 2>/dev/null || echo "fail")
            GO_RESULT=$(cat /tmp/go-result 2>/dev/null || echo "fail")
            PHP_RESULT=$(cat /tmp/php-result 2>/dev/null || echo "fail")
            PLAYWRIGHT_RESULT=$(cat /tmp/playwright-result 2>/dev/null || echo "fail")

            # Handle killed tests
            if [ "$TESTS_KILLED_EARLY" = "true" ]; then
              [ "$LARAVEL_RESULT" = "running" ] && LARAVEL_RESULT="killed"
              [ "$GO_RESULT" = "running" ] && GO_RESULT="killed"
              [ "$PHP_RESULT" = "running" ] && PHP_RESULT="killed"
              [ "$PLAYWRIGHT_RESULT" = "running" ] && PLAYWRIGHT_RESULT="killed"
            fi

            echo ""
            echo "=== Parallel Test Results ==="
            echo "iznik-batch: $LARAVEL_RESULT"
            echo "Go: $GO_RESULT"
            echo "iznik-server: $PHP_RESULT"
            echo "Playwright: $PLAYWRIGHT_RESULT"

            # Set environment variables for later steps
            if [ "$LARAVEL_RESULT" = "pass" ]; then
              echo "LARAVEL_TESTS_PASSED=true" >> $BASH_ENV
            else
              echo "LARAVEL_TESTS_PASSED=false" >> $BASH_ENV
            fi

            if [ "$GO_RESULT" = "pass" ]; then
              echo "GO_TESTS_PASSED=true" >> $BASH_ENV
            else
              echo "GO_TESTS_PASSED=false" >> $BASH_ENV
            fi

            if [ "$PHP_RESULT" = "pass" ]; then
              echo "PHP_TESTS_PASSED=true" >> $BASH_ENV
            else
              echo "PHP_TESTS_PASSED=false" >> $BASH_ENV
            fi

            if [ "$PLAYWRIGHT_RESULT" = "pass" ]; then
              echo "PLAYWRIGHT_TESTS_PASSED=true" >> $BASH_ENV
            else
              echo "PLAYWRIGHT_TESTS_PASSED=false" >> $BASH_ENV
            fi

            # === WATCHDOG CLEANUP ===
            # Kill the watchdog since tests completed (either pass or fail)
            if [ -f /tmp/watchdog-pid ]; then
              WATCHDOG_PID=$(cat /tmp/watchdog-pid)
              kill $WATCHDOG_PID 2>/dev/null || true
              echo "üõë Watchdog timer stopped"
            fi

            # Check if we hit the watchdog timeout
            if [ -f /tmp/watchdog-triggered ]; then
              echo ""
              echo "‚è∞ =============================================="
              echo "‚è∞ TESTS TERMINATED BY WATCHDOG TIMEOUT"
              echo "‚è∞ The overall job timeout (48 min) was reached."
              echo "‚è∞ This may indicate tests are hanging or too slow."
              echo "‚è∞ Artifacts will be collected for debugging."
              echo "‚è∞ =============================================="
              echo ""
              # Don't exit 1 here - let artifacts be collected
              # The test results will show as failed anyway
            fi

            # Check test suite results
            if [ "$LARAVEL_RESULT" != "pass" ] || [ "$GO_RESULT" != "pass" ] || [ "$PHP_RESULT" != "pass" ] || [ "$PLAYWRIGHT_RESULT" != "pass" ]; then
              echo "‚ùå One or more test suites failed"
              # Show failed test output files
              echo ""
              echo "=== Test Output Files ==="
              for f in ~/test-output/*.out; do
                if [ -f "$f" ]; then
                  echo "üìÑ $f: $(wc -l < "$f") lines"
                fi
              done
              # Don't exit 1 here - let artifacts be collected
              # The "Evaluate overall test results" step (with when: always) will handle the failure exit
            else
              echo "‚úÖ All tests passed!"
            fi
          no_output_timeout: 50m

      - store_artifacts:
          path: ~/test-output
          destination: test-output

      # Coverage is now uploaded inline via status API - no separate step needed

      - collect-artifacts

      - run:
          name: Evaluate overall test results
          command: |
            echo "=== Overall Test Results ==="

            # All tests (required)
            if [ "$LARAVEL_TESTS_PASSED" = "true" ] && [ "$GO_TESTS_PASSED" = "true" ] && [ "$PHP_TESTS_PASSED" = "true" ] && [ "$PLAYWRIGHT_TESTS_PASSED" = "true" ]; then
              echo "‚úÖ All tests passed successfully!"
              echo "ALL_TESTS_PASSED=true" >> $BASH_ENV
            else
              echo "‚ùå Tests failed"
              echo "Laravel: $LARAVEL_TESTS_PASSED, Go: $GO_TESTS_PASSED, PHP: $PHP_TESTS_PASSED, Playwright: $PLAYWRIGHT_TESTS_PASSED"
              echo ""

              # Extract and display failure details from test output files
              # This ensures failures are visible even if earlier output was truncated

              if [ "$LARAVEL_TESTS_PASSED" != "true" ] && [ -f ~/test-output/laravel.out ]; then
                echo "=== Laravel (iznik-batch) Failure Details ==="
                # Show PHPUnit failure summary (lines after "There were X failures:")
                if grep -q "There were .* failures" ~/test-output/laravel.out; then
                  grep -A 100 "There were .* failures" ~/test-output/laravel.out | head -80
                else
                  # Show last 50 lines if no standard failure marker
                  echo "(Showing last 50 lines of output)"
                  tail -50 ~/test-output/laravel.out
                fi
                echo ""
              fi

              if [ "$GO_TESTS_PASSED" != "true" ] && [ -f ~/test-output/go.out ]; then
                echo "=== Go Test Failure Details ==="
                # Show lines containing FAIL or error
                if grep -q "FAIL\|Error\|panic" ~/test-output/go.out; then
                  grep -B 2 -A 5 "FAIL\|Error\|panic" ~/test-output/go.out | head -60
                else
                  echo "(Showing last 50 lines of output)"
                  tail -50 ~/test-output/go.out
                fi
                echo ""
              fi

              if [ "$PHP_TESTS_PASSED" != "true" ] && [ -f ~/test-output/php.out ]; then
                echo "=== PHP (iznik-server) Failure Details ==="
                if grep -q "FAILURES\|There were .* failures" ~/test-output/php.out; then
                  grep -A 100 "There were .* failures" ~/test-output/php.out | head -80
                else
                  echo "(Showing last 50 lines of output)"
                  tail -50 ~/test-output/php.out
                fi
                echo ""
              fi

              if [ "$PLAYWRIGHT_TESTS_PASSED" != "true" ] && [ -f ~/test-output/playwright.out ]; then
                echo "=== Playwright Failure Details ==="
                # Show lines containing failure markers
                if grep -q "‚úò\|Error:\|failed" ~/test-output/playwright.out; then
                  grep -B 2 -A 10 "‚úò\|Error:\|failed" ~/test-output/playwright.out | head -60
                else
                  echo "(Showing last 50 lines of output)"
                  tail -50 ~/test-output/playwright.out
                fi
                echo ""
              fi

              echo "=== Full logs available in artifacts ==="
              echo "Download test-output/*.out files for complete details"
              exit 1
            fi
          when: always

      - run:
          name: Auto-merge master to production
          command: |
            if [ "$ALL_TESTS_PASSED" != "true" ]; then
              echo "‚è≠Ô∏è Skipping auto-merge: not all tests passed"
              exit 0
            fi

            if [ "$CIRCLE_BRANCH" != "master" ]; then
              echo "‚è≠Ô∏è Skipping auto-merge: not on master branch"
              exit 0
            fi

            echo "üîÄ Auto-merging master to production in iznik-nuxt3..."

            git config --global user.email "circleci@freegle.org"
            git config --global user.name "CircleCI Auto-merge"

            cd iznik-nuxt3
            git fetch origin master:master
            git fetch origin production:production
            git checkout production

            MASTER_COMMIT_MSG=$(git log master -1 --pretty=%B | head -n 1)

            if git merge master -m "Auto-merge master to production after successful tests - Original commit: $MASTER_COMMIT_MSG"; then
              if git push origin production; then
                echo "üéâ Successfully pushed merged changes to production!"
              else
                echo "‚ùå Failed to push to production branch"
                exit 1
              fi
            else
              echo "‚ùå Merge failed - conflicts detected"
              git merge --abort
              exit 1
            fi

  # === App Build Jobs ===

  increment-version:
    docker:
      - image: cimg/base:stable
    steps:
      - run:
          name: Increment Version Number
          command: |
            CURRENT_VERSION="${CURRENT_VERSION:-3.2.37}"
            echo "Current version: $CURRENT_VERSION"
            major=$(echo "$CURRENT_VERSION" | cut -d. -f1)
            minor=$(echo "$CURRENT_VERSION" | cut -d. -f2)
            patch=$(echo "$CURRENT_VERSION" | cut -d. -f3)
            NEW_PATCH=$((patch + 1))
            NEW_VERSION="$major.$minor.$NEW_PATCH"
            echo "New version: $NEW_VERSION"
            echo "$NEW_VERSION" > .new_version
            cat .new_version
      - persist_to_workspace:
          root: .
          paths:
            - .new_version

  build-android-debug:
    executor: android-executor
    steps:
      - checkout
      - run:
          name: Install Node.js 22
          command: |
            curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
            sudo apt-get install -y nodejs
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Verify Node.js and npm versions
          command: |
            node --version
            npm --version
      - restore_cache:
          keys:
            - npm-deps-v1-{{ checksum "package-lock.json" }}
            - npm-deps-v1-
      - run:
          name: Install Node.js Dependencies
          command: npm ci
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - save_cache:
          key: npm-deps-v1-{{ checksum "package-lock.json" }}
          paths:
            - node_modules
      - run:
          name: Build Nuxt App (Debug)
          command: |
            export ISAPP=true
            export APP_ENV=development
            echo "üîß Building debug version for master branch"
            npm run generate
      - run:
          name: Setup Firebase Configuration
          command: |
            if [ -n "$GOOGLE_SERVICES_JSON_BASE64" ]; then
              echo "Decoding google-services.json from environment variable"
              echo "$GOOGLE_SERVICES_JSON_BASE64" | base64 -d > android/app/google-services.json
              if [ -f android/app/google-services.json ]; then
                FILE_SIZE=$(wc -c < android/app/google-services.json)
                echo "‚úÖ File created: $FILE_SIZE bytes"
                if python3 -m json.tool android/app/google-services.json > /dev/null 2>&1; then
                  echo "‚úÖ Valid JSON structure"
                  echo "üì± Project ID: $(python3 -c "import json; print(json.load(open('android/app/google-services.json'))['project_info']['project_id'])")"
                else
                  echo "‚ùå ERROR: Invalid JSON - Firebase will not work!"
                  exit 1
                fi
              else
                echo "‚ùå ERROR: File was not created!"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è  GOOGLE_SERVICES_JSON_BASE64 not set - Push notifications will not work"
            fi
      - run:
          name: Sync Capacitor to Android
          command: npx cap sync android
      - run:
          name: Make gradlew executable
          command: chmod +x android/gradlew
      - run:
          name: Create Debug Keystore
          command: |
            mkdir -p ~/.android
            if [ ! -f ~/.android/debug.keystore ]; then
              echo "Creating debug keystore..."
              keytool -genkey -v \
                -keystore ~/.android/debug.keystore \
                -storepass android \
                -alias androiddebugkey \
                -keypass android \
                -keyalg RSA \
                -keysize 2048 \
                -validity 10000 \
                -dname "CN=Android Debug,O=Android,C=US"
              echo "‚úÖ Debug keystore created"
            else
              echo "‚úÖ Debug keystore already exists"
            fi
      - run:
          name: Build Debug APK
          command: |
            cd android
            ./gradlew assembleDebug --stacktrace
            echo "‚úÖ Debug APK built successfully"
            echo ""
            echo "üìã APK Info:"
            ls -lh app/build/outputs/apk/debug/
      - store_artifacts:
          path: android/app/build/outputs/apk/debug/app-debug.apk
          destination: freegle-debug.apk
      - run:
          name: Build Complete
          command: |
            echo "üéâ Debug build complete!"
            echo "üì± Download APK from CircleCI artifacts tab"

  build-android:
    executor: android-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Install Node.js 22
          command: |
            curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
            sudo apt-get install -y nodejs
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Verify Node.js and npm versions
          command: |
            node --version
            npm --version
      - restore_cache:
          keys:
            - npm-deps-v1-{{ checksum "package-lock.json" }}
            - npm-deps-v1-
      - run:
          name: Install Node.js Dependencies
          command: npm ci
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - save_cache:
          key: npm-deps-v1-{{ checksum "package-lock.json" }}
          paths:
            - node_modules
      - run:
          name: Update Mobile Version in config.js
          command: |
            if [ ! -f .new_version ]; then
              echo "‚ùå ERROR: Version file not found at .new_version"
              exit 1
            fi
            NEW_VERSION=$(cat .new_version)
            echo "üì± Using version from workspace: $NEW_VERSION"
            if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "‚ùå ERROR: Invalid version format '$NEW_VERSION'. Expected format: X.Y.Z"
              exit 1
            fi
            sed -i "s/MOBILE_VERSION: '[0-9]*\.[0-9]*\.[0-9]*'/MOBILE_VERSION: '$NEW_VERSION'/" config.js
            if grep -q "MOBILE_VERSION: '$NEW_VERSION'" config.js; then
              echo "‚úÖ Successfully updated config.js with version $NEW_VERSION"
              grep "MOBILE_VERSION:" config.js
            else
              echo "‚ùå ERROR: Failed to update config.js"
              exit 1
            fi
      - run:
          name: Build Nuxt App
          command: |
            export ISAPP=true
            export APP_ENV=production
            if [ -n "$SENTRY_DSN_APP_FD" ]; then
              export SENTRY_DSN="$SENTRY_DSN_APP_FD"
              echo "‚úÖ Using app-specific Sentry DSN for error tracking"
            else
              echo "‚ö†Ô∏è  SENTRY_DSN_APP_FD not set - app will use default Sentry DSN"
            fi
            npm run generate
      - run:
          name: Setup Firebase Configuration
          command: |
            if [ -n "$GOOGLE_SERVICES_JSON_BASE64" ]; then
              echo "Decoding google-services.json from environment variable"
              echo "$GOOGLE_SERVICES_JSON_BASE64" | base64 -d > android/app/google-services.json
              if [ -f android/app/google-services.json ]; then
                FILE_SIZE=$(wc -c < android/app/google-services.json)
                echo "‚úÖ File created: $FILE_SIZE bytes"
                if python3 -m json.tool android/app/google-services.json > /dev/null 2>&1; then
                  echo "‚úÖ Valid JSON structure"
                  echo "üì± Project ID: $(python3 -c "import json; print(json.load(open('android/app/google-services.json'))['project_info']['project_id'])")"
                else
                  echo "‚ùå ERROR: Invalid JSON - Firebase will not work!"
                  exit 1
                fi
              else
                echo "‚ùå ERROR: File was not created!"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è  GOOGLE_SERVICES_JSON_BASE64 not set - Push notifications will not work"
            fi
      - run:
          name: Sync Capacitor to Android
          command: npx cap sync android
      - run:
          name: Make gradlew executable
          command: chmod +x android/gradlew
      - restore_cache:
          keys:
            - bundle-v1-{{ checksum "Gemfile.lock" }}
            - bundle-v1-
      - setup-android-fastlane
      - save_cache:
          key: bundle-v1-{{ checksum "Gemfile.lock" }}
          paths:
            - vendor/bundle
      - run:
          name: Build and Deploy to Google Play Beta Track
          command: bundle exec fastlane android beta
      - run:
          name: Update CircleCI Version Variable
          command: |
            if [ ! -f .new_version ]; then
              echo "‚ö†Ô∏è  .new_version file not found - skipping version update"
              exit 0
            fi
            NEW_VERSION=$(cat .new_version)
            echo "üìù Updating CircleCI CURRENT_VERSION to: ${NEW_VERSION}"
            curl -X DELETE \
              -H "Circle-Token: ${CIRCLECI_API_TOKEN}" \
              "https://circleci.com/api/v2/project/gh/Freegle/iznik-nuxt3/envvar/CURRENT_VERSION"
            curl -X POST \
              -H "Circle-Token: ${CIRCLECI_API_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"name\":\"CURRENT_VERSION\",\"value\":\"${NEW_VERSION}\"}" \
              "https://circleci.com/api/v2/project/gh/Freegle/iznik-nuxt3/envvar"
            echo "‚úÖ Updated CURRENT_VERSION to ${NEW_VERSION}"
      - store_artifacts:
          path: android/app/build/outputs/bundle/release/
          destination: android-bundle
      - store_artifacts:
          path: android/app/build/outputs/apk/release/
          destination: android-apk

  build-ios:
    executor: macos-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Install Node.js 22
          command: |
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm install 22
            nvm use 22
            nvm alias default 22
            echo 'export NVM_DIR="$HOME/.nvm"' >> $BASH_ENV
            echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> $BASH_ENV
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Verify Node.js and npm versions
          command: |
            node --version
            npm --version
      - run:
          name: Install Node.js Dependencies
          command: npm ci
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Update Mobile Version in config.js
          command: |
            if [ ! -f .new_version ]; then
              echo "‚ùå ERROR: Version file not found at .new_version"
              exit 1
            fi
            NEW_VERSION=$(cat .new_version)
            echo "üì± Using version from workspace: $NEW_VERSION"
            if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "‚ùå ERROR: Invalid version format '$NEW_VERSION'. Expected format: X.Y.Z"
              exit 1
            fi
            sed -i '' "s/MOBILE_VERSION: '[0-9]*\.[0-9]*\.[0-9]*'/MOBILE_VERSION: '$NEW_VERSION'/" config.js
            if grep -q "MOBILE_VERSION: '$NEW_VERSION'" config.js; then
              echo "‚úÖ Successfully updated config.js with version $NEW_VERSION"
              grep "MOBILE_VERSION:" config.js
            else
              echo "‚ùå ERROR: Failed to update config.js"
              exit 1
            fi
      - run:
          name: Build Nuxt App
          command: |
            export ISAPP=true
            export APP_ENV=production
            if [ -n "$SENTRY_DSN_APP_FD" ]; then
              export SENTRY_DSN="$SENTRY_DSN_APP_FD"
              echo "‚úÖ Using app-specific Sentry DSN for error tracking"
            else
              echo "‚ö†Ô∏è  SENTRY_DSN_APP_FD not set - app will use default Sentry DSN"
            fi
            npm run generate
      - run:
          name: Sync Capacitor to iOS
          command: npx cap sync ios
      - run:
          name: Setup Firebase Configuration for iOS
          command: |
            if [ -n "$GOOGLE_SERVICE_INFO_PLIST_BASE64" ]; then
              echo "Decoding GoogleService-Info.plist from environment variable"
              echo "$GOOGLE_SERVICE_INFO_PLIST_BASE64" | base64 --decode > ios/App/App/GoogleService-Info.plist
              if [ -f ios/App/App/GoogleService-Info.plist ]; then
                echo "‚úÖ GoogleService-Info.plist successfully created"
                ls -lh ios/App/App/GoogleService-Info.plist
              else
                echo "‚ùå Failed to create GoogleService-Info.plist"
                exit 1
              fi
            else
              echo "‚ùå GOOGLE_SERVICE_INFO_PLIST_BASE64 environment variable not set"
              exit 1
            fi
      - run:
          name: Install Fastlane
          command: |
            bundle config set --local path 'vendor/bundle'
            bundle update fastlane
            bundle install
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Setup iOS Certificates
          command: |
            mkdir -p ~/certificates
            echo "$IOS_DISTRIBUTION_CERT" | base64 --decode > ~/certificates/ios_distribution.p12
            echo "$IOS_PROVISIONING_PROFILE" | base64 --decode > ~/certificates/ios_appstore.mobileprovision
            KEYCHAIN_PATH=~/Library/Keychains/temp.keychain-db
            KEYCHAIN_PASSWORD=circleci
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
            security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
            security default-keychain -s "$KEYCHAIN_PATH"
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
            security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"
            echo "export IOS_CERTIFICATE_PATH=~/certificates/ios_distribution.p12" >> $BASH_ENV
            echo "export IOS_PROVISIONING_PROFILE_PATH=~/certificates/ios_appstore.mobileprovision" >> $BASH_ENV
            echo "export KEYCHAIN_NAME=$KEYCHAIN_PATH" >> $BASH_ENV
            echo "export KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $BASH_ENV
      - run:
          name: Build and Deploy to TestFlight
          command: |
            export TERM=xterm-256color
            bundle exec fastlane ios beta
          no_output_timeout: 30m
      - run:
          name: Update CircleCI Version Variable
          command: |
            if [ ! -f .new_version ]; then
              echo "‚ö†Ô∏è  .new_version file not found - skipping version update"
              exit 0
            fi
            NEW_VERSION=$(cat .new_version)
            echo "üìù Updating CircleCI CURRENT_VERSION to: ${NEW_VERSION}"
            curl -X DELETE \
              -H "Circle-Token: ${CIRCLECI_API_TOKEN}" \
              "https://circleci.com/api/v2/project/gh/Freegle/iznik-nuxt3/envvar/CURRENT_VERSION"
            curl -X POST \
              -H "Circle-Token: ${CIRCLECI_API_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"name\":\"CURRENT_VERSION\",\"value\":\"${NEW_VERSION}\"}" \
              "https://circleci.com/api/v2/project/gh/Freegle/iznik-nuxt3/envvar"
            echo "‚úÖ Updated CURRENT_VERSION to ${NEW_VERSION}"
      - store_artifacts:
          path: build/
          destination: ios-build

  auto-promote-production:
    executor: android-executor
    steps:
      - checkout
      - restore_cache:
          keys:
            - bundle-v1-{{ checksum "Gemfile.lock" }}
            - bundle-v1-
      - setup-android-fastlane
      - run:
          name: Auto-promote Beta to Production
          command: bundle exec fastlane android auto_promote

  auto-submit-ios:
    executor: macos-executor
    steps:
      - checkout
      - run:
          name: Install Node.js 22
          command: |
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm install 22
            nvm use 22
            nvm alias default 22
            echo 'export NVM_DIR="$HOME/.nvm"' >> $BASH_ENV
            echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> $BASH_ENV
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Install Fastlane
          command: |
            gem install bundler
            bundle update fastlane
            bundle install
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Auto-submit Latest TestFlight Build to App Store Review
          command: bundle exec fastlane ios auto_submit

  auto-release-ios:
    executor: macos-executor
    steps:
      - checkout
      - run:
          name: Install Node.js 22
          command: |
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm install 22
            nvm use 22
            nvm alias default 22
            echo 'export NVM_DIR="$HOME/.nvm"' >> $BASH_ENV
            echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> $BASH_ENV
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Install Fastlane
          command: |
            gem install bundler
            bundle update fastlane
            bundle install
          max_auto_reruns: 3
          auto_rerun_delay: 10s
      - run:
          name: Auto-release Apps from Pending Developer Release
          command: bundle exec fastlane ios auto_release
