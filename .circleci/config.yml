version: 2.1

# Define reusable commands to reduce duplication
commands:
  setup-dependencies:
    description: "Install system dependencies and docker-compose"
    steps:
      - run:
          name: Install system dependencies
          command: |
            sudo apt-get update
            sudo apt-get install -y curl jq

            # Install latest docker-compose
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            docker-compose --version

  start-docker-services:
    description: "Start Docker Compose services with proper setup"
    parameters:
      reason:
        type: string
        default: "Starting Docker services"
    steps:
      - run:
          name: Start Docker services
          max_auto_reruns: 3
          auto_rerun_delay: 10s
          command: |
            echo "<< parameters.reason >>"

            # Clean up any existing containers first
            docker-compose down --remove-orphans || true
            docker system prune -f || true

            # Fix memory overcommit for Redis
            sudo sysctl vm.overcommit_memory=1
            echo "Set vm.overcommit_memory=1 for Redis"

            # Create secrets files after cleanup, right before Docker startup
            echo "Creating secrets files after cleanup:"
            mkdir -p secrets
            echo "placeholder" > secrets/lovejunk-api.txt
            echo "placeholder" > secrets/lovejunk-secret.txt
            echo "placeholder" > secrets/partner-key.txt
            echo "placeholder" > secrets/partner-name.txt
            echo "placeholder" > secrets/image-domain.txt
            echo "Current working directory: $(pwd)"
            ls -la secrets/

            # Start services in detached mode
            docker-compose up -d

            echo "Waiting for basic services to start..."
            sleep 30

            echo "Service status:"
            docker-compose ps

  wait-for-basic-services:
    description: "Wait for API v1 and v2 services to be healthy"
    steps:
      - run:
          name: Wait for API services to be ready
          command: |
            echo "Waiting for API v1 and v2 services to be healthy..."

            start_time=$(date +%s)
            timeout_duration=600  # 10 minutes for basic services

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Timeout waiting for API services after 10 minutes"
                exit 1
              fi

              # Check if status service is responding
              if curl -f -s http://localhost:8081 > /dev/null 2>&1; then
                echo "‚úÖ Status service is responding!"

                # Get health status from status service
                health_response=$(curl -s http://localhost:8081/api/status/all 2>/dev/null || echo '{}')

                # Check if API v1 and v2 are healthy
                apiv1_status=$(echo "$health_response" | jq -r '.apiv1.status // "unknown"')
                apiv2_status=$(echo "$health_response" | jq -r '.apiv2.status // "unknown"')

                if [ "$apiv1_status" = "success" ] && [ "$apiv2_status" = "success" ]; then
                  echo "‚úÖ API v1 and v2 services are healthy!"
                  break
                else
                  elapsed_min=$((elapsed / 60))
                  echo "[${elapsed_min}m] API v1: $apiv1_status, API v2: $apiv2_status - waiting..."
                fi
              else
                echo "Status service not yet responding..."
              fi

              sleep 10
            done

            echo "üéâ API services are ready!"
          no_output_timeout: 15m

  run-go-tests:
    description: "Run Go tests in the API v2 container"
    parameters:
      reason:
        type: string
        default: "Running Go tests"
    steps:
      - run:
          name: Run Go tests
          command: |
            echo "üß™ << parameters.reason >>..."

            # Set up test environment first
            echo "Setting up test environment..."
            docker-compose exec -T apiv1 sh -c "cd /var/www/iznik && php install/testenv.php"

            echo "Setting up Go-specific test data..."
            # Copy Go test environment file from container to temp location
            docker cp freegle-apiv2:/app/.circleci/testenv.php /tmp/go-testenv-from-container.php
            # Fix the include path to work in the apiv1 container
            sed -i "s#dirname(__FILE__) . '/../include/config.php'#'/var/www/iznik/include/config.php'#" /tmp/go-testenv-from-container.php
            # Copy back to apiv1 container
            docker cp /tmp/go-testenv-from-container.php freegle-apiv1:/var/www/iznik/go-testenv.php
            # Run Go test environment setup
            docker-compose exec -T apiv1 sh -c "cd /var/www/iznik && php go-testenv.php"

            echo "Running Go tests..."
            docker-compose exec -T apiv2 sh -c "export CGO_ENABLED=1 && go mod tidy && go test -v -race -coverprofile=coverage.out ./test/... -coverpkg ./..."

            echo "‚úÖ Go tests passed!"
            echo "GO_TESTS_PASSED=true" >> $BASH_ENV

  run-php-tests:
    description: "Run PHPUnit tests via the status service API"
    parameters:
      reason:
        type: string
        default: "Running PHPUnit tests"
    steps:
      - run:
          name: Run PHPUnit tests
          command: |
            echo "üêò << parameters.reason >>..."

            # Trigger tests via API
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/php)
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger PHP tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ PHP tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring PHP test progress..."
            start_time=$(date +%s)
            timeout_duration=2700  # 45 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå PHP tests timed out after 45 minutes"
                exit 1
              fi

              sleep 10
              status_response=$(curl -s http://localhost:8081/api/tests/php/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status"
              echo "Message: $message"

              if [ "$status" = "completed" ]; then
                echo "üéâ PHP tests completed!"
                echo "‚úÖ PHPUnit tests passed!"
                echo "PHP_TESTS_PASSED=true" >> $BASH_ENV

                # PHPUnit output files will be collected by collect-artifacts command

                break
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå PHP tests failed!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30

                # PHPUnit output files will be collected by collect-artifacts command

                # Show the failure details from the PHPUnit debug log
                echo ""
                echo "Extracting failure details from PHPUnit output..."
                docker exec freegle-apiv1 sh -c '
                  if [ -f /tmp/phpunit-debug.log ]; then
                    echo "=== TEST FAILURES ==="
                    grep "##teamcity\[testFailed" /tmp/phpunit-debug.log | head -10 | while read -r line; do
                      test_name=$(echo "$line" | sed "s/.*name='\''\\([^'\'']*\\)'\''.*/\\1/")
                      message=$(echo "$line" | sed "s/.*message='\''\\([^'\'']*\\)'\''.*/\\1/")
                      details=$(echo "$line" | sed "s/.*details='\''\\([^'\'']*\\)'\''.*/\\1/" | sed "s/|n/\\n/g")
                      if [ -n "$test_name" ]; then
                        echo "‚ùå $test_name"
                        [ -n "$message" ] && echo "   Message: $message"
                        [ -n "$details" ] && echo "   Details: $details"
                      fi
                    done

                    echo ""
                    echo "=== TEST SUMMARY ==="
                    tail -20 /tmp/phpunit-debug.log | grep -E "Tests:|FAILURES!|Skipped:" || echo "No summary found"
                  else
                    echo "Debug log not found"
                  fi
                ' || echo "Could not extract failure details"

                echo "PHP_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

  wait-for-prod-container:
    description: "Wait for production container to be healthy"
    steps:
      - run:
          name: Wait for production container to be healthy
          command: |
            echo "‚è≥ Waiting for production container to be fully healthy before Playwright tests..."

            start_time=$(date +%s)
            timeout_duration=1200  # 20 minutes for prod build

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Timeout waiting for production container after 20 minutes"
                exit 1
              fi

              # Check prod container health specifically
              health_response=$(curl -s http://localhost:8081/api/status/all 2>/dev/null || echo '{}')
              prod_status=$(echo "$health_response" | jq -r '.["freegle-prod"].status // "unknown"')

              if [ "$prod_status" = "success" ]; then
                echo "‚úÖ Production container is healthy and ready for Playwright tests!"
                break
              else
                elapsed_min=$((elapsed / 60))
                echo "[${elapsed_min}m] Production container status: $prod_status - waiting..."

                # Show prod container logs if it's having issues
                if [ "$prod_status" = "failed" ] || [ "$prod_status" = "error" ]; then
                  echo "Production container logs (last 10 lines):"
                  docker logs freegle-freegle-prod --tail 10 2>&1 || true
                fi

                sleep 15
              fi
            done
          no_output_timeout: 25m

  run-playwright-tests:
    description: "Run Playwright tests via the status service API"
    parameters:
      reason:
        type: string
        default: "Running Playwright tests"
    steps:
      - run:
          name: Run Playwright tests
          command: |
            echo "üé≠ << parameters.reason >>..."

            # Trigger tests via API
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/playwright)
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger Playwright tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ Playwright tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring Playwright test progress..."
            start_time=$(date +%s)
            timeout_duration=2700  # 45 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚è∞ Playwright tests timed out after 45 minutes"
                exit 1
              fi

              sleep 10

              status_response=$(curl -s http://localhost:8081/api/tests/playwright/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')
              completed=$(echo "$status_response" | jq -r '.completedTests // 0')
              total=$(echo "$status_response" | jq -r '.totalTests // 0')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status, Progress: $completed/$total tests"
              echo "Message: $message"

              if [ "$status" = "completed" ]; then
                success=$(echo "$status_response" | jq -r '.success // false')
                echo "üéâ Playwright tests completed! Success: $success"

                if [ "$success" = "true" ]; then
                  echo "‚úÖ All Playwright tests passed!"
                  echo "PLAYWRIGHT_TESTS_PASSED=true" >> $BASH_ENV
                  break
                else
                  echo "‚ùå Some Playwright tests failed!"
                  echo "Test logs:"
                  echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30
                  echo "PLAYWRIGHT_TESTS_PASSED=false" >> $BASH_ENV
                  exit 1
                fi
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå Playwright tests failed to run!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30
                echo "PLAYWRIGHT_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

  upload-coverage:
    description: "Upload coverage reports to Coveralls"
    steps:
      - run:
          name: Upload coverage to Coveralls
          command: |
            echo "üìä Uploading coverage reports to Coveralls..."

            # Check if COVERALLS_REPO_TOKEN is set
            if [ -z "${COVERALLS_REPO_TOKEN}" ]; then
              echo "‚ö†Ô∏è COVERALLS_REPO_TOKEN not set - skipping coverage upload"
              echo "To enable coverage upload, add COVERALLS_REPO_TOKEN to CircleCI project environment variables"
              exit 0
            fi

            # Install coveralls uploader
            npm install -g coveralls

            # Copy Playwright coverage from container if available
            if docker exec freegle-playwright test -f /app/monocart-report/coverage/lcov.info 2>/dev/null; then
              echo "Copying Playwright coverage from container..."
              docker cp freegle-playwright:/app/monocart-report/coverage/lcov.info ./playwright-coverage.lcov

              if [ -f ./playwright-coverage.lcov ]; then
                echo "Uploading Playwright coverage to Coveralls..."
                cat ./playwright-coverage.lcov | coveralls || echo "Warning: Playwright coverage upload failed"
              else
                echo "Failed to copy Playwright coverage file"
              fi
            else
              echo "No Playwright coverage file found in container at /app/monocart-report/coverage/lcov.info"
            fi

            # Upload PHPUnit coverage if available
            if [ -f ~/artifacts/phpunit/phpunit-coverage.xml ]; then
              echo "PHPUnit coverage file found but needs conversion to lcov format"
              # Note: PHPUnit coverage is in XML format, would need conversion
            fi

            # Upload Go coverage if available
            if docker cp freegle-apiv2:/app/coverage.out /tmp/go-coverage.out 2>/dev/null; then
              echo "Converting Go coverage to lcov format..."
              # Install gcov2lcov if needed
              go install github.com/jandelgado/gcov2lcov@latest || true
              if command -v gcov2lcov > /dev/null; then
                gcov2lcov -infile=/tmp/go-coverage.out -outfile=/tmp/go-coverage.lcov
                cat /tmp/go-coverage.lcov | coveralls || echo "Warning: Go coverage upload failed"
              else
                echo "gcov2lcov not available for Go coverage conversion"
              fi
            else
              echo "No Go coverage file found"
            fi
          when: always
          environment:
            COVERALLS_SERVICE_NAME: circleci
            COVERALLS_SERVICE_JOB_ID: "${CIRCLE_BUILD_NUM}"
            COVERALLS_REPO_TOKEN: "${COVERALLS_REPO_TOKEN}"

  collect-artifacts:
    description: "Collect build artifacts and logs"
    steps:
      - run:
          name: Collect artifacts
          command: |
            mkdir -p ~/artifacts

            # Collect Docker logs
            if docker-compose ps > /dev/null 2>&1; then
              echo "Collecting Docker logs..."
              docker-compose logs > ~/artifacts/docker-logs.txt 2>&1 || true
              docker-compose ps > ~/artifacts/docker-status.txt 2>&1 || true
            fi

            # Collect cron script logs and error logs
            echo "Collecting cron and error logs..."
            docker exec freegle-apiv1 find /var/log -name "*.log" -type f 2>/dev/null | head -10 | while read logfile; do
              filename=$(basename "$logfile")
              docker cp "freegle-apiv1:$logfile" "~/artifacts/apiv1-$filename" 2>/dev/null || echo "Could not copy $logfile"
            done

            # Collect PHP error logs if they exist
            docker exec freegle-apiv1 find /tmp -name "*error*" -o -name "*debug*" -type f 2>/dev/null | head -10 | while read logfile; do
              filename=$(basename "$logfile")
              docker cp "freegle-apiv1:$logfile" "~/artifacts/apiv1-$filename" 2>/dev/null || echo "Could not copy $logfile"
            done

            # Collect PHPUnit test output files (if they exist)
            echo "Collecting PHPUnit output files..."
            mkdir -p ~/artifacts/phpunit
            docker cp freegle-apiv1:/tmp/phpunit-output.log ~/artifacts/phpunit/phpunit-output.log 2>/dev/null || echo "No PHPUnit output log found"
            docker cp freegle-apiv1:/tmp/phpunit-debug.log ~/artifacts/phpunit/phpunit-debug.log 2>/dev/null || echo "No PHPUnit debug log found"
            docker cp freegle-apiv1:/tmp/phpunit-coverage.xml ~/artifacts/phpunit/phpunit-coverage.xml 2>/dev/null || echo "No PHPUnit coverage file found"

            # Collect Go test coverage
            echo "Collecting Go test coverage..."
            mkdir -p ~/artifacts/go

            echo "Checking Go container files for coverage:"
            docker exec freegle-apiv2 ls -la /app/ | grep -E "(coverage|\.out|\.html)" || echo "No coverage files visible"

            # Copy coverage.out file
            if docker exec freegle-apiv2 test -f /app/coverage.out; then
              echo "Copying Go coverage.out..."
              if docker cp freegle-apiv2:/app/coverage.out ~/artifacts/go/coverage.out; then
                echo "‚úÖ Go coverage.out copied successfully ($(stat -c%s ~/artifacts/go/coverage.out) bytes)"
              else
                echo "‚ùå Failed to copy Go coverage.out"
              fi
            else
              echo "‚ö†Ô∏è Go coverage.out not found in container"
            fi

            # Copy coverage.html file
            if docker exec freegle-apiv2 test -f /app/coverage.html; then
              echo "Copying Go coverage.html..."
              if docker cp freegle-apiv2:/app/coverage.html ~/artifacts/go/coverage.html; then
                echo "‚úÖ Go coverage.html copied successfully ($(stat -c%s ~/artifacts/go/coverage.html) bytes)"
              else
                echo "‚ùå Failed to copy Go coverage.html"
              fi
            else
              echo "‚ö†Ô∏è Go coverage.html not found in container"
            fi

            # Generate Go coverage HTML if we have the coverage.out file but no HTML
            if [ -f ~/artifacts/go/coverage.out ] && [ ! -f ~/artifacts/go/coverage.html ]; then
              echo "Generating Go coverage HTML from coverage.out..."
              if docker exec freegle-apiv2 sh -c "go tool cover -html=coverage.out -o coverage.html"; then
                echo "Go coverage HTML generated in container"
                if docker cp freegle-apiv2:/app/coverage.html ~/artifacts/go/coverage.html; then
                  echo "‚úÖ Generated Go coverage HTML copied successfully ($(stat -c%s ~/artifacts/go/coverage.html) bytes)"
                else
                  echo "‚ùå Failed to copy generated Go coverage HTML"
                fi
              else
                echo "‚ùå Could not generate Go coverage HTML"
              fi
            fi

            echo "Final Go artifacts:"
            ls -la ~/artifacts/go/ || echo "No Go artifacts directory"

            # Collect Playwright test artifacts
            echo "Collecting Playwright test artifacts..."
            mkdir -p ~/artifacts/playwright

            echo "Checking Playwright container files for test artifacts:"
            docker exec freegle-playwright ls -la /app/ | grep -E "(coverage|nyc|test-results|playwright-report|monocart)" || echo "No test artifact files visible"

            # Collect Playwright report via HTTP
            echo "Collecting Playwright HTML report from HTTP server..."
            if curl -s http://localhost:9323 > ~/artifacts/playwright-report.html; then
              if [ -s ~/artifacts/playwright-report.html ]; then
                echo "‚úÖ Playwright HTML report collected via HTTP ($(stat -c%s ~/artifacts/playwright-report.html) bytes)"
              else
                echo "‚ö†Ô∏è Playwright HTML report file is empty"
                rm -f ~/artifacts/playwright-report.html
              fi
            else
              echo "‚ùå Failed to collect Playwright HTML report via HTTP"
            fi

            # Collect Playwright test results
            if docker exec freegle-playwright test -d /app/test-results; then
              echo "Copying Playwright test-results..."
              if docker cp freegle-playwright:/app/test-results ~/artifacts/playwright/test-results; then
                echo "‚úÖ Playwright test-results copied successfully"
                find ~/artifacts/playwright/test-results -name "*.png" -o -name "*.webm" | wc -l | xargs echo "Found test artifacts:"
              else
                echo "‚ùå Failed to copy Playwright test-results"
              fi
            else
              echo "‚ö†Ô∏è Playwright test-results directory not found in container"
            fi

            # Collect Playwright report directory
            if docker exec freegle-playwright test -d /app/playwright-report; then
              echo "Copying Playwright report directory..."
              if docker cp freegle-playwright:/app/playwright-report ~/artifacts/playwright/playwright-report; then
                echo "‚úÖ Playwright report directory copied successfully"
              else
                echo "‚ùå Failed to copy Playwright report directory"
              fi
            else
              echo "‚ö†Ô∏è Playwright report directory not found in container"
            fi

            # Collect standard coverage reports
            if docker exec freegle-playwright test -d /app/coverage; then
              echo "Copying Playwright coverage directory..."
              if docker cp freegle-playwright:/app/coverage ~/artifacts/playwright/coverage; then
                echo "‚úÖ Playwright coverage directory copied successfully"
                ls -la ~/artifacts/playwright/coverage/ | head -5
              else
                echo "‚ùå Failed to copy Playwright coverage directory"
              fi
            else
              echo "‚ö†Ô∏è Playwright coverage directory not found in container"
            fi

            # Collect NYC coverage reports
            if docker exec freegle-playwright test -d /app/nyc_output; then
              echo "Copying NYC coverage output..."
              if docker cp freegle-playwright:/app/nyc_output ~/artifacts/playwright/nyc_output; then
                echo "‚úÖ NYC coverage output copied successfully"
                ls -la ~/artifacts/playwright/nyc_output/ | head -5
              else
                echo "‚ùå Failed to copy NYC coverage output"
              fi
            else
              echo "‚ö†Ô∏è NYC coverage output directory not found in container"
            fi

            # Check for monocart coverage reports (used by some Playwright configs)
            if docker exec freegle-playwright test -d /app/monocart-report; then
              echo "Copying monocart coverage report..."
              if docker cp freegle-playwright:/app/monocart-report ~/artifacts/playwright/monocart-report; then
                echo "‚úÖ Monocart coverage report copied successfully"
                find ~/artifacts/playwright/monocart-report -name "*.html" -o -name "*.json" | wc -l | xargs echo "Found monocart files:"
              else
                echo "‚ùå Failed to copy monocart coverage report"
              fi
            else
              echo "‚ö†Ô∏è Monocart coverage report not found in container"
            fi

            echo "Final Playwright artifacts:"
            ls -la ~/artifacts/playwright/ || echo "No Playwright artifacts directory"

            # Collect system info
            echo "CircleCI Build: $CIRCLE_BUILD_NUM" > ~/artifacts/build-info.txt
            echo "Branch: $CIRCLE_BRANCH" >> ~/artifacts/build-info.txt
            echo "Commit: $CIRCLE_SHA1" >> ~/artifacts/build-info.txt
            date >> ~/artifacts/build-info.txt

            # List what we collected
            echo ""
            echo "Artifacts collected:"
            find ~/artifacts -type f -name "*.xml" -o -name "*.html" -o -name "*.out" -o -name "*.png" -o -name "*.jpg" | head -20
          when: always
      - store_artifacts:
          path: ~/artifacts

# Define executors
executors:
  machine-executor:
    machine:
      image: ubuntu-2204:2024.05.1
    resource_class: large  # 4 vCPUs, 15 GB RAM for faster builds
    working_directory: ~/project
    environment:
      DOCKER_BUILDKIT: 1
      COMPOSE_DOCKER_CLI_BUILD: 1

# Define jobs
jobs:
  build-and-test:
    executor: machine-executor
    steps:
      - checkout

      - run:
          name: Initialize and update git submodules
          command: |
            echo "Initializing and updating git submodules..."
            git submodule init
            git submodule update --recursive
            echo "Submodule status:"
            git submodule status

      - setup-dependencies

      - start-docker-services:
          reason: "Starting all Docker services"

      # Wait for basic API services to be ready
      - wait-for-basic-services

      # Run Go tests immediately (doesn't need prod container)
      - run-go-tests:
          reason: "Running Go tests immediately after API services start"

      # Run PHP tests after Go tests (doesn't need prod container)
      - run-php-tests:
          reason: "Running PHPUnit tests after Go tests complete"

      # Wait for prod container to be healthy before Playwright tests
      - wait-for-prod-container

      # Run Playwright tests only after prod is ready
      - run-playwright-tests:
          reason: "Running Playwright tests after production container is healthy"

      - collect-artifacts

      - upload-coverage

      - run:
          name: Evaluate overall test results
          command: |
            echo "=== Overall Test Results ==="
            echo "GO_TESTS_PASSED=${GO_TESTS_PASSED:-not_run}"
            echo "PHP_TESTS_PASSED=${PHP_TESTS_PASSED:-not_run}"
            echo "PLAYWRIGHT_TESTS_PASSED=${PLAYWRIGHT_TESTS_PASSED:-not_run}"

            # Determine if all required tests passed
            if [ "$GO_TESTS_PASSED" = "true" ] && [ "$PHP_TESTS_PASSED" = "true" ] && [ "$PLAYWRIGHT_TESTS_PASSED" = "true" ]; then
              echo "‚úÖ All tests passed successfully!"
              echo "ALL_TESTS_PASSED=true" >> $BASH_ENV
            else
              echo "‚ùå Not all tests passed"
              echo "  Go tests: $GO_TESTS_PASSED"
              echo "  PHPUnit tests: $PHP_TESTS_PASSED"
              echo "  Playwright tests: $PLAYWRIGHT_TESTS_PASSED"
              exit 1
            fi
          when: always

      - run:
          name: Auto-merge master to production
          command: |
            # Only run if all tests passed
            if [ "$ALL_TESTS_PASSED" != "true" ]; then
              echo "‚è≠Ô∏è Skipping auto-merge: not all tests passed"
              exit 0
            fi

            # Only run on master branch builds
            if [ "$CIRCLE_BRANCH" != "master" ]; then
              echo "‚è≠Ô∏è Skipping auto-merge: not on master branch (current: $CIRCLE_BRANCH)"
              exit 0
            fi

            echo "üîÄ Starting auto-merge of master to production branch in iznik-nuxt3..."

            # Configure git
            git config --global user.email "circleci@freegle.org"
            git config --global user.name "CircleCI Auto-merge"

            # Navigate to iznik-nuxt3 submodule
            cd iznik-nuxt3

            # Fetch latest changes
            echo "üì• Fetching latest changes from origin..."
            git fetch origin master:master
            git fetch origin production:production

            # Checkout production branch
            echo "üìù Checking out production branch..."
            git checkout production

            # Merge master into production
            echo "üîÄ Merging master into production..."
            if git merge master -m "Auto-merge master to production after successful tests"; then
              echo "‚úÖ Merge successful!"

              # Push to production branch
              echo "üì§ Pushing to production branch..."
              if git push origin production; then
                echo "üéâ Successfully pushed merged changes to production!"
                echo "Production branch has been updated with latest master changes."
              else
                echo "‚ùå Failed to push to production branch"
                echo "This might be due to permissions or network issues."
                echo "Manual intervention may be required."
                exit 1
              fi
            else
              echo "‚ùå Merge failed - there may be conflicts"
              echo "Manual intervention required to resolve conflicts."
              git merge --abort
              exit 1
            fi

            echo "‚ú® Auto-merge completed successfully!"

      # Temporarily disabled for debugging - resources left running for SSH access
      # - run:
      #     name: Clean up Docker resources
      #     command: |
      #       echo "üßπ Cleaning up Docker resources..."
      #       docker-compose down --remove-orphans || true
      #       docker system prune -f || true
      #     when: always

# Define workflows
workflows:
  version: 2
  build-test:
    jobs:
      - build-and-test