version: 2.1

# Define reusable commands to reduce duplication
commands:
  setup-dependencies:
    description: "Install system dependencies and docker-compose"
    steps:
      - run:
          name: Install system dependencies
          command: |
            sudo apt-get update
            sudo apt-get install -y curl jq

            # Install latest docker-compose
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            docker-compose --version

  start-docker-services:
    description: "Start Docker Compose services with proper setup"
    parameters:
      reason:
        type: string
        default: "Starting Docker services"
    steps:
      - run:
          name: Start Docker services
          command: |
            echo "<< parameters.reason >>"

            # Clean up any existing containers first
            docker-compose down --remove-orphans || true
            docker system prune -f || true

            # Fix memory overcommit for Redis
            sudo sysctl vm.overcommit_memory=1
            echo "Set vm.overcommit_memory=1 for Redis"

            # Create secrets files after cleanup, right before Docker startup
            echo "Creating secrets files after cleanup:"
            mkdir -p secrets
            echo "placeholder" > secrets/lovejunk-api.txt
            echo "placeholder" > secrets/lovejunk-secret.txt
            echo "placeholder" > secrets/partner-key.txt
            echo "placeholder" > secrets/partner-name.txt
            echo "placeholder" > secrets/image-domain.txt
            echo "Current working directory: $(pwd)"
            ls -la secrets/

            # Start services in detached mode
            docker-compose up -d

            echo "Waiting for basic services to start..."
            sleep 30

            echo "Service status:"
            docker-compose ps

  wait-for-basic-services:
    description: "Wait for API v1 and v2 services to be healthy"
    steps:
      - run:
          name: Wait for API services to be ready
          command: |
            echo "Waiting for API v1 and v2 services to be healthy..."

            start_time=$(date +%s)
            timeout_duration=600  # 10 minutes for basic services

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Timeout waiting for API services after 10 minutes"
                exit 1
              fi

              # Check if status service is responding
              if curl -f -s http://localhost:8081 > /dev/null 2>&1; then
                echo "‚úÖ Status service is responding!"

                # Get health status from status service
                health_response=$(curl -s http://localhost:8081/api/status/all 2>/dev/null || echo '{}')

                # Check if API v1 and v2 are healthy
                apiv1_status=$(echo "$health_response" | jq -r '.apiv1.status // "unknown"')
                apiv2_status=$(echo "$health_response" | jq -r '.apiv2.status // "unknown"')

                if [ "$apiv1_status" = "success" ] && [ "$apiv2_status" = "success" ]; then
                  echo "‚úÖ API v1 and v2 services are healthy!"
                  break
                else
                  elapsed_min=$((elapsed / 60))
                  echo "[${elapsed_min}m] API v1: $apiv1_status, API v2: $apiv2_status - waiting..."
                fi
              else
                echo "Status service not yet responding..."
              fi

              sleep 10
            done

            echo "üéâ API services are ready!"
          no_output_timeout: 15m

  run-go-tests:
    description: "Run Go tests in the API v2 container"
    parameters:
      reason:
        type: string
        default: "Running Go tests"
    steps:
      - run:
          name: Run Go tests
          command: |
            echo "üß™ << parameters.reason >>..."

            # Set up test environment first
            echo "Setting up test environment..."
            docker-compose exec -T apiv1 sh -c "cd /var/www/iznik && php install/testenv.php"

            echo "Setting up Go-specific test data..."
            # Copy Go test environment file from container to temp location
            docker cp freegle-apiv2:/app/.circleci/testenv.php /tmp/go-testenv-from-container.php
            # Fix the include path to work in the apiv1 container
            sed -i "s#dirname(__FILE__) . '/../include/config.php'#'/var/www/iznik/include/config.php'#" /tmp/go-testenv-from-container.php
            # Copy back to apiv1 container
            docker cp /tmp/go-testenv-from-container.php freegle-apiv1:/var/www/iznik/go-testenv.php
            # Run Go test environment setup
            docker-compose exec -T apiv1 sh -c "cd /var/www/iznik && php go-testenv.php"

            echo "Running Go tests..."
            docker-compose exec -T apiv2 sh -c "export CGO_ENABLED=1 && go mod tidy && go test -v -race -coverprofile=coverage.out ./test/... -coverpkg ./..."

            echo "‚úÖ Go tests passed!"
            echo "GO_TESTS_PASSED=true" >> $BASH_ENV

  run-php-tests:
    description: "Run PHPUnit tests via the status service API"
    parameters:
      reason:
        type: string
        default: "Running PHPUnit tests"
    steps:
      - run:
          name: Run PHPUnit tests
          command: |
            echo "üêò << parameters.reason >>..."

            # Trigger tests via API
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/php)
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger PHP tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ PHP tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring PHP test progress..."
            start_time=$(date +%s)
            timeout_duration=2700  # 45 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå PHP tests timed out after 45 minutes"
                exit 1
              fi

              sleep 10
              status_response=$(curl -s http://localhost:8081/api/tests/php/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status"
              echo "Message: $message"

              if [ "$status" = "completed" ]; then
                echo "üéâ PHP tests completed!"
                echo "‚úÖ PHPUnit tests passed!"
                echo "PHP_TESTS_PASSED=true" >> $BASH_ENV

                # Copy coverage file as artifact
                echo "Copying PHPUnit coverage file..."
                mkdir -p ~/artifacts/phpunit
                docker cp freegle-apiv1:/tmp/phpunit-coverage.xml ~/artifacts/phpunit/phpunit-coverage.xml || \
                  echo "WARNING: Coverage file not found"

                break
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå PHP tests failed!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30
                echo "PHP_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

  wait-for-prod-container:
    description: "Wait for production container to be healthy"
    steps:
      - run:
          name: Wait for production container to be healthy
          command: |
            echo "‚è≥ Waiting for production container to be fully healthy before Playwright tests..."

            start_time=$(date +%s)
            timeout_duration=1200  # 20 minutes for prod build

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚ùå Timeout waiting for production container after 20 minutes"
                exit 1
              fi

              # Check prod container health specifically
              health_response=$(curl -s http://localhost:8081/api/status/all 2>/dev/null || echo '{}')
              prod_status=$(echo "$health_response" | jq -r '.["freegle-prod"].status // "unknown"')

              if [ "$prod_status" = "success" ]; then
                echo "‚úÖ Production container is healthy and ready for Playwright tests!"
                break
              else
                elapsed_min=$((elapsed / 60))
                echo "[${elapsed_min}m] Production container status: $prod_status - waiting..."

                # Show prod container logs if it's having issues
                if [ "$prod_status" = "failed" ] || [ "$prod_status" = "error" ]; then
                  echo "Production container logs (last 10 lines):"
                  docker logs freegle-freegle-prod --tail 10 2>&1 || true
                fi

                sleep 15
              fi
            done
          no_output_timeout: 25m

  run-playwright-tests:
    description: "Run Playwright tests via the status service API"
    parameters:
      reason:
        type: string
        default: "Running Playwright tests"
    steps:
      - run:
          name: Run Playwright tests
          command: |
            echo "üé≠ << parameters.reason >>..."

            # Trigger tests via API
            response=$(curl -s -w "%{http_code}" -X POST -H "Content-Type: application/json" http://localhost:8081/api/tests/playwright)
            http_code="${response: -3}"

            if [ "$http_code" -ne "200" ]; then
              echo "‚ùå Failed to trigger Playwright tests. HTTP code: $http_code"
              echo "Response: $response"
              exit 1
            fi

            echo "‚úÖ Playwright tests triggered successfully"

            # Monitor test progress with timeout
            echo "üìä Monitoring Playwright test progress..."
            start_time=$(date +%s)
            timeout_duration=2700  # 45 minutes

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))

              if [ $elapsed -gt $timeout_duration ]; then
                echo "‚è∞ Playwright tests timed out after 45 minutes"
                exit 1
              fi

              sleep 10

              status_response=$(curl -s http://localhost:8081/api/tests/playwright/status || echo '{"status":"error"}')
              status=$(echo "$status_response" | jq -r '.status // "unknown"')
              message=$(echo "$status_response" | jq -r '.message // "No message"')
              completed=$(echo "$status_response" | jq -r '.completedTests // 0')
              total=$(echo "$status_response" | jq -r '.totalTests // 0')

              elapsed_min=$((elapsed / 60))
              echo "[${elapsed_min}m] Status: $status, Progress: $completed/$total tests"
              echo "Message: $message"

              if [ "$status" = "completed" ]; then
                success=$(echo "$status_response" | jq -r '.success // false')
                echo "üéâ Playwright tests completed! Success: $success"

                if [ "$success" = "true" ]; then
                  echo "‚úÖ All Playwright tests passed!"
                  echo "PLAYWRIGHT_TESTS_PASSED=true" >> $BASH_ENV
                  break
                else
                  echo "‚ùå Some Playwright tests failed!"
                  echo "Test logs:"
                  echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30
                  echo "PLAYWRIGHT_TESTS_PASSED=false" >> $BASH_ENV
                  exit 1
                fi
              elif [ "$status" = "failed" ] || [ "$status" = "error" ]; then
                echo "‚ùå Playwright tests failed to run!"
                echo "Error details:"
                echo "$status_response" | jq -r '.logs // "No logs available"' | tail -30
                echo "PLAYWRIGHT_TESTS_PASSED=false" >> $BASH_ENV
                exit 1
              fi
            done

  collect-artifacts:
    description: "Collect build artifacts and logs"
    steps:
      - run:
          name: Collect artifacts
          command: |
            mkdir -p ~/artifacts

            # Collect Docker logs
            if docker-compose ps > /dev/null 2>&1; then
              echo "Collecting Docker logs..."
              docker-compose logs > ~/artifacts/docker-logs.txt 2>&1 || true
              docker-compose ps > ~/artifacts/docker-status.txt 2>&1 || true
            fi

            # Collect test reports
            if curl -s http://localhost:9323 > ~/artifacts/playwright-report.html 2>/dev/null; then
              echo "Collected Playwright HTML report"
            fi

            # Collect system info
            echo "CircleCI Build: $CIRCLE_BUILD_NUM" > ~/artifacts/build-info.txt
            echo "Branch: $CIRCLE_BRANCH" >> ~/artifacts/build-info.txt
            echo "Commit: $CIRCLE_SHA1" >> ~/artifacts/build-info.txt
            date >> ~/artifacts/build-info.txt
          when: always
      - store_artifacts:
          path: ~/artifacts

# Define executors
executors:
  machine-executor:
    machine:
      image: ubuntu-2204:2024.05.1
    resource_class: large  # 4 vCPUs, 15 GB RAM for faster builds
    working_directory: ~/project
    environment:
      DOCKER_BUILDKIT: 1
      COMPOSE_DOCKER_CLI_BUILD: 1

# Define jobs
jobs:
  build-and-test:
    executor: machine-executor
    steps:
      - checkout:
          # Checkout with submodules
          post:
            - git submodule sync
            - git submodule update --init --recursive

      - setup-dependencies

      - start-docker-services:
          reason: "Starting all Docker services"

      # Wait for basic API services to be ready
      - wait-for-basic-services

      # Run Go tests immediately (doesn't need prod container)
      - run-go-tests:
          reason: "Running Go tests immediately after API services start"

      # Run PHP tests after Go tests (doesn't need prod container)
      - run-php-tests:
          reason: "Running PHPUnit tests after Go tests complete"

      # Wait for prod container to be healthy before Playwright tests
      - wait-for-prod-container

      # Run Playwright tests only after prod is ready
      - run-playwright-tests:
          reason: "Running Playwright tests after production container is healthy"

      - collect-artifacts

      - run:
          name: Evaluate overall test results
          command: |
            echo "=== Overall Test Results ==="
            echo "GO_TESTS_PASSED=${GO_TESTS_PASSED:-not_run}"
            echo "PHP_TESTS_PASSED=${PHP_TESTS_PASSED:-not_run}"
            echo "PLAYWRIGHT_TESTS_PASSED=${PLAYWRIGHT_TESTS_PASSED:-not_run}"

            # Determine if all required tests passed
            if [ "$GO_TESTS_PASSED" = "true" ] && [ "$PHP_TESTS_PASSED" = "true" ] && [ "$PLAYWRIGHT_TESTS_PASSED" = "true" ]; then
              echo "‚úÖ All tests passed successfully!"
            else
              echo "‚ùå Not all tests passed"
              echo "  Go tests: $GO_TESTS_PASSED"
              echo "  PHPUnit tests: $PHP_TESTS_PASSED"
              echo "  Playwright tests: $PLAYWRIGHT_TESTS_PASSED"
              exit 1
            fi
          when: always

      - run:
          name: Clean up Docker resources
          command: |
            echo "üßπ Cleaning up Docker resources..."
            docker-compose down --remove-orphans || true
            docker system prune -f || true
          when: always

# Define workflows
workflows:
  version: 2
  build-test:
    jobs:
      - build-and-test